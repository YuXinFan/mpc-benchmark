#include <math.h>
#include "oqueue.oh"

/*struct oring_queue {
	oram * ring;
	obliv size_t head;
	obliv size_t tail;
	size_t size;
};

oring_queue * oring_queue_new(size_t size, size_t elsz) {
	oring_queue * result = malloc(sizeof(oring_queue));
	result->ring = oram_new(size+1, elsz);
	result->size = size;
	result->head = 0;
	result->tail = 0;
	return result;
}

void oring_queue_free(oring_queue * queue) {
	oram_free(queue->ring);
	free(queue);
}

obliv bool oring_queue_empty(oring_queue * queue) {
	return (queue->head == queue->tail);
}

obliv bool oring_queue_empty_obliv(oring_queue * queue) obliv {
	return (queue->head == queue->tail);
}

obliv bool oring_queue_full(oring_queue * queue) {
	return ((queue->head == queue->tail + 1) | ((queue->tail == queue->size) & (queue->head == 0)));
}

obliv bool oring_queue_full_obliv(oring_queue * queue) obliv {
	return ((queue->head == queue->tail + 1) | ((queue->tail == queue->size) & (queue->head == 0)));
}

void oring_queue_push(oring_queue * queue, obliv uint32_t * input) {
	oram_write(queue->ring, input, queue->tail);
	obliv if (queue->tail < queue->size) {
		queue->tail++;	
	} else {
		queue->tail=0;
	}
}

void oring_queue_push_obliv(oring_queue * queue, obliv uint32_t * input) obliv {
	oram_write_obliv(queue->ring, input, queue->tail);
	obliv if (queue->tail < queue->size) {
		queue->tail++;	
	} else {
		queue->tail=0;
	}
}

void oring_queue_pop(obliv uint32_t * output, oring_queue * queue) {
	obliv if (queue->head != queue->tail) {
		oram_read_obliv(output, queue->ring, queue->head);
		obliv if (queue->head < queue->size) {
			queue->head++;	
		} else {
			queue->head=0;
		}
	}
}

void oring_queue_pop_obliv(obliv uint32_t * output, oring_queue * queue) obliv {
	obliv if (queue->head != queue->tail) {
		oram_read_obliv(output, queue->ring, queue->head);
		obliv if (queue->head < queue->size) {
			queue->head++;	
		} else {
			queue->head=0;
		}
	}
}*/




struct oqueue {
	oqueue * child;
	OcCopy * cpy;
	size_t layer_index;
	bool dynamic_sizing;
	obliv uint8_t head;
	obliv uint8_t tail;
	obliv uint32_t current_elements;
	uint8_t push_time;
	uint8_t pop_time;
	void * data;
};

static void* element(OcCopy* cpy,void* arr,int x) obliv
  { return x*cpy->eltsize+(char*)arr; }

obliv bool oqueue_empty(oqueue * layer) obliv {
	return (layer->current_elements == 0);
}

obliv bool oqueue_full (oqueue * layer) obliv {
	if (layer->child == NULL) {
		return (layer->tail == 6);
	} else {
		return (layer->tail == 6 & oqueue_full(layer->child));
	}
}

obliv bool oqueue_push(oqueue * layer, void * input) obliv {
	obliv bool success = false;
	~obliv(en) {
		if (layer->child != NULL) {
			if (layer->push_time == 1) {
				obliv if (en & (layer->tail >= 5)) {
					obliv if (oqueue_push(layer->child, element(layer->cpy,layer->data,3))) {
						ocCopy(layer->cpy,element(layer->cpy,layer->data,3), element(layer->cpy,layer->data,5));
						layer->tail -= 2;	
					}
				}
				layer->push_time = 0;
			} else {
				layer->push_time ++;
			}
		}
	}
	obliv if (layer->tail < 6) {
		for (uint8_t ii = 0; ii < 6; ii++) {
			obliv if (ii == layer->tail) {
				ocCopy(layer->cpy,element(layer->cpy,layer->data,ii), input);
				success = true;
				layer->current_elements ++;
			}	
		}
		layer->tail++;
	}
	return success;
}

obliv bool oqueue_pop(void * output, oqueue * layer) obliv {
	obliv bool success = false;

	~obliv(en) {
		if (layer->pop_time == 0) {
			if (layer->child == NULL) {
				obliv if (en & layer->head >= 2) {
					for (uint8_t ii = 0; ii < 4; ii ++) {
						ocCopy(layer->cpy,element(layer->cpy,layer->data,ii), element(layer->cpy,layer->data,ii + 2));
					}
					layer->head -= 2;
					layer->tail -= 2;
				}
			} else {
				obliv if (en & layer->head >= 2) {
					ocCopy(layer->cpy,element(layer->cpy,layer->data,0), element(layer->cpy,layer->data,2));
					layer->head -= 2;
					obliv if(~oqueue_pop(element(layer->cpy,layer->data,1), layer->child)) {
						for (uint8_t ii = 1; ii < 4; ii ++) {
							ocCopy(layer->cpy,element(layer->cpy,layer->data,ii), element(layer->cpy,layer->data,ii + 2));
						}
						layer->tail -= 2;
					}
				}
			}
			layer->pop_time = 1;
		} else {
			layer->pop_time --;
		}
	}

	obliv if (layer->head < 3 & layer->head != layer->tail) {
		for (uint8_t ii = 0; ii < 3; ii++) {
			obliv if (ii == layer->head) {
				ocCopy(layer->cpy,output,element(layer->cpy,layer->data,ii));
				success = true;
				layer->current_elements --;
			}
		}
		layer->head++;
	}
	return success;
}

oqueue * oqueue_new_static(OcCopy * cpy, int n) {
	size_t base_size = cpy->eltsize / ocCopyChar.eltsize;
	size_t queue_size = 0;
	size_t layer_index = 0;
	size_t this_elsz;
	oqueue * result;
	oqueue * this_layer = NULL;
	oqueue * last_layer = NULL;

	while (queue_size < n) {
		this_layer = malloc(sizeof(oqueue));
		this_layer->layer_index = layer_index;
		this_layer->head = 0;
		this_layer->tail = 0;
		this_layer->current_elements = 0;
		this_layer->push_time = 0;
		this_layer->pop_time = 0;
		this_layer->dynamic_sizing = false;
		this_layer->child = NULL;

		this_elsz = base_size * pow(2, layer_index);
		this_layer->cpy = malloc(sizeof(*this_layer->cpy));
		*this_layer->cpy = ocCopyCharN(this_elsz);
		this_layer->data = calloc(this_elsz * 6, sizeof(obliv uint8_t));

		if (last_layer == NULL) {
			result = this_layer;
		} else {
			last_layer->child = this_layer;
		}
		last_layer = this_layer;

		queue_size += 3 * pow(2, layer_index);
		layer_index++;
	}

	return result;
}

void oqueue_free(oqueue * layer) {
	if (layer->child != NULL) {
		oqueue_free(layer->child);
	}
	free(layer->cpy);
	free(layer->data);
	free(layer);
}