#include "ograph.oh"
#include "oqueue.oh"

void middle_increment(OcCopy * cpy, void * oram_block, void * external_block) obliv {
	((obliv uint32_t *) oram_block)[1]++;
}

void write_first_read_others(OcCopy * cpy, void * oram_block, void * external_block) obliv {
	((obliv uint32_t *) oram_block)[0] = ((obliv uint32_t *) external_block)[0];
	((obliv uint32_t *) external_block)[1] = ((obliv uint32_t *) oram_block)[1];
	((obliv uint32_t *) external_block)[2] = ((obliv uint32_t *) oram_block)[2];
}

void read_and_increment_last(OcCopy * cpy, void * oram_block, void * external_block) obliv {
	((obliv uint32_t *) external_block)[0] = ((obliv uint32_t *) oram_block)[0];
	((obliv uint32_t *) external_block)[1] = ((obliv uint32_t *) oram_block)[1];
	((obliv uint32_t *) external_block)[2] = ((obliv uint32_t *) oram_block)[2];
	((obliv uint32_t *) oram_block)[2]++;
}

ograph_adjacency_matrix * ograph_build_adjacency_matrix(size_t vertices, ograph_edge * edges_input, size_t edges) {
	ograph_adjacency_matrix * result = malloc(sizeof(ograph_adjacency_matrix));
	result->cpy3 = ocCopyIntN(3);
	result->cpy2 = ocCopyIntN(2);
	result->matrix = oram_new(ORAM_TYPE_AUTO, &result->cpy3, edges);
	result->layout = oram_new(ORAM_TYPE_AUTO, &result->cpy2, vertices);
	result->vertices = vertices;
	result->edges = edges;
	oram * edge_counts = oram_new(ORAM_TYPE_AUTO, &result->cpy3, vertices);
	obliv uint32_t three32_1[3];
	obliv uint32_t three32_2[3];
	obliv uint32_t three32_3[3];
	
	obliv uint32_t one = 1;

	for (size_t ii = 0; ii < edges; ii++) {
		oram_apply(edge_counts, three32_1, middle_increment, edges_input[ii].v1);
	}

	obliv uint32_t total = 0;
	for (size_t ii = 0; ii < vertices; ii++) {
		three32_1[0] = total;
		oram_apply(edge_counts, three32_1, write_first_read_others, ii);
		oram_write(result->layout, three32_1, ii);
		total += three32_1[1];
	}

	for (size_t ii = 0; ii < edges; ii++) {
		oram_apply(edge_counts, three32_1, read_and_increment_last, edges_input[ii].v1);
		oram_read(three32_2, edge_counts, edges_input[ii].v2);

		three32_3[0]=edges_input[ii].v2;
		three32_3[1]=three32_2[0];
		three32_3[2]=three32_2[1];

		oram_write(result->matrix, three32_3, three32_1[0] + three32_1[2]);
	}

	oram_free(edge_counts);
	return result;
}

void ograph_free_adjacency_matrix(ograph_adjacency_matrix * adj) {
	oram_free(adj->matrix);
	oram_free(adj->layout);
	free(adj);
}

ograph_vertex_list * ograph_vertex_list_new(size_t size) {
	ograph_vertex_list * result = malloc(sizeof(ograph_vertex_list));
	result->public_size = size;
	result->size = 0;
	result->elsz = 1;
	result->list = calloc(result->public_size, sizeof(obliv uint32_t));
	return result;
}

void ograph_get_nth_adjacent_vertex(uint32_t * out, ograph_adjacency_matrix * adj, obliv uint32_t vertex, obliv uint32_t n) {
	obliv uint32_t two32[2];
	oram_read(two32, adj->layout, vertex);
	oram_read(out, adj->matrix, two32[0]+n);
}

void ograph_get_nth_adjacent_vertex_from_triple(ograph_vertex_list * out, ograph_adjacency_matrix * adj, obliv uint32_t * vertex, obliv uint32_t n) {
	oram_read(out, adj->matrix, vertex[1]+n);
}

void ograph_get_nth_adjacent_vertex_obliv(uint32_t * out, ograph_adjacency_matrix * adj, obliv uint32_t vertex, obliv uint32_t n) obliv {
	obliv uint32_t two32[2];
	oram_read(two32, adj->layout, vertex);
	oram_read(out, adj->matrix, two32[0]+n);
}

void ograph_get_nth_adjacent_vertex_from_triple_obliv(ograph_vertex_list * out, ograph_adjacency_matrix * adj, obliv uint32_t * vertex, obliv uint32_t n) obliv {
	oram_read(out, adj->matrix, vertex[1]+n);
}

void ograph_free_vertex_list(ograph_vertex_list * vlist) {
	free(vlist->list);
	free(vlist);
}

void distance_writer(OcCopy * cpy, void * oram_block, void * external_block) obliv {
	obliv uint32_t existing_distance = * ((obliv uint32_t *) oram_block);
	obliv if (existing_distance == 0) {
		* ((obliv uint32_t *) oram_block) = * ((obliv uint32_t *) external_block);
	}
	* ((obliv uint32_t *) external_block) = existing_distance;
}

ograph_vertex_list * ograph_breadth_first_search(ograph_adjacency_matrix * adj, obliv uint32_t source_vertex) {
	OcCopy cpy3 = ocCopyIntN(3);
	oqueue * q = oqueue_new_static(&cpy3, adj->vertices);
	oram * visited_vertices = oram_new(ORAM_TYPE_AUTO, &ocCopyInt, adj->vertices);

	obliv uint32_t one = 1;
	obliv uint32_t visited_vertices_count = 1;
	obliv uint32_t this_vertex[3];
	obliv uint32_t next_vertex[3];
	obliv uint32_t last_distance = 1, this_distance;
	obliv size_t vertex_index = 0;
	obliv size_t edge_index = 0;
	obliv bool vloop = false;
	obliv bool queue_empty;

	this_vertex[0] = source_vertex;
	oram_read(&this_vertex[1], adj->layout, source_vertex);
	oram_write(visited_vertices, &one, source_vertex);

	for (size_t ii = 0; ii < adj->vertices + adj->edges; ii++) {
		obliv if (vloop) {
			queue_empty = oqueue_empty(q);
			obliv if (queue_empty == 0) {
				oqueue_pop(this_vertex, q);
			}
			oram_read(&last_distance, visited_vertices, this_vertex[0]);
			vloop = false;
			edge_index = 0;
		} else {
			ograph_get_nth_adjacent_vertex_from_triple_obliv(next_vertex, adj, this_vertex, edge_index);
			this_distance = last_distance + 1;
			oram_apply(visited_vertices, &this_distance, distance_writer, next_vertex[0]);
			obliv if (this_distance == 0) {
				oqueue_push(q, next_vertex);
			}
			edge_index++;
			obliv if (edge_index >= this_vertex[2]) {
				vloop = true;
			}
		}
	}

	ograph_vertex_list * result = ograph_vertex_list_new(adj->vertices);

	for (size_t ii = 0; ii < adj->vertices; ii++) {
		obliv uint32_t temp;
		oram_read(&temp, visited_vertices, ii);
		temp -= 1;
		result->list[ii] = temp;
	}

	oram_free(visited_vertices);
	oqueue_free(q);

	return result;
}