#include "bitpropagate.oh"
#include "bitpropagate.h"
#include "floram_util.oh"
#include "ackutil.h"
#include <omp.h>
#include <obliv.h>

struct bitpropagator {
	uint32_t startlevel;
	uint32_t endlevel;
	size_t size;
	size_t blockmultiple;
	obliv uint8_t * toplevel;
	uint8_t * toplevel_local;
	obliv uint8_t * blockzero;
	obliv uint8_t * blocktemp_A;
	obliv uint8_t * blocktemp_B;
	obliv uint8_t * activeblock_A;
	obliv uint8_t * activeblock_B;
	obliv uint8_t * expanded_A;
	obliv uint8_t * expanded_B;
	obliv uint8_t * Z;
	obliv bool * advicebits;
	obliv uint8_t * keyL;
	obliv uint8_t * keyR;
	omp_lock_t * locks;
	bitpropagator_offline * bpo;
};

void bitpropagator_Z_pusher(bitpropagator * bp, bitpropagator_offline * bpo, ProtocolDesc* pd) {

	ocSetCurrentProto(pd);

	bool advicebit_local_l, advicebit_local_r;
	uint8_t * Z_local = malloc(BLOCKSIZE);

	for (size_t ii = bp->startlevel+1; ii <= bp->endlevel; ii++) {
		size_t thislevel = ii- bp->startlevel -1;
		omp_set_lock(&bp->locks[thislevel]);

		for (size_t jj = 0; jj < BLOCKSIZE/sizeof(uint64_t); jj++) revealOblivLLong(&((uint64_t *)Z_local)[jj], ((obliv uint64_t *)(&bp->Z[thislevel*BLOCKSIZE]))[jj], 1);
		revealOblivBool(&advicebit_local_l, bp->advicebits[thislevel*2+0], 1);
		revealOblivBool(&advicebit_local_r, bp->advicebits[thislevel*2+1], 1);
		for (size_t jj = 0; jj < BLOCKSIZE/sizeof(uint64_t); jj++) revealOblivLLong(&((uint64_t *)Z_local)[jj], ((obliv uint64_t *)(&bp->Z[thislevel*BLOCKSIZE]))[jj], 2);
		revealOblivBool(&advicebit_local_l, bp->advicebits[thislevel*2+0], 2);
		revealOblivBool(&advicebit_local_r, bp->advicebits[thislevel*2+1], 2);
	
		bitpropagator_offline_push_Z(bpo, Z_local, advicebit_local_l, advicebit_local_r, ii);
	}

	free(Z_local);
}

void bitpropagator_traverselevels(bitpropagator * bp, obliv size_t * indexp) {

	obliv uint32_t levelindex;
	obliv size_t index = *indexp;
	obliv bool control_bit_A_next, control_bit_B_next;
	obliv bool control_bit_A = ((obliv bool *)bp->activeblock_A)[0];
	obliv bool control_bit_B = ((obliv bool *)bp->activeblock_B)[0];

	for (size_t ii = bp->startlevel+1; ii <= bp->endlevel; ii++) {
		levelindex = (index >> (bp->endlevel - ii)) & 1;

		obliv uint8_t * Z = &bp->Z[(ii - bp->startlevel - 1)*BLOCKSIZE];

		//first expand our active blocks into two blocks (L/R)
		online_prf_double(bp->expanded_A, &bp->expanded_A[BLOCKSIZE], bp->activeblock_A, bp->activeblock_A, bp->keyL, bp->keyR);
		online_prf_double(bp->expanded_B, &bp->expanded_B[BLOCKSIZE], bp->activeblock_B, bp->activeblock_B, bp->keyL, bp->keyR);

		obliv if (levelindex == 0) {
			//copy the branch to be kept
			ocCopyN(&ocCopyChar, bp->activeblock_A, bp->expanded_A, BLOCKSIZE);
			ocCopyN(&ocCopyChar, bp->activeblock_B, bp->expanded_B, BLOCKSIZE);
			//Z = block_A XOR block_B for the silenced branch
			ocCopyN(&ocCopyChar, Z, &bp->expanded_A[BLOCKSIZE], BLOCKSIZE);
			for (size_t jj = 0; jj < BLOCKSIZE; jj ++) {
				Z[jj] ^= bp->expanded_B[BLOCKSIZE+jj];
			}
		} else {
			//copy the branch to be kept
			ocCopyN(&ocCopyChar, bp->activeblock_A, &bp->expanded_A[BLOCKSIZE], BLOCKSIZE);
			ocCopyN(&ocCopyChar, bp->activeblock_B, &bp->expanded_B[BLOCKSIZE], BLOCKSIZE);
			//Z = block_A XOR block_B for the silenced branch
			ocCopyN(&ocCopyChar, Z, bp->expanded_A, BLOCKSIZE);
			for (size_t jj = 0; jj < BLOCKSIZE; jj ++) {
				Z[jj] ^= bp->expanded_B[jj];
			}
		}

		bitpropagator_getadvice(&bp->advicebits[(ii - bp->startlevel - 1)*2], bp->expanded_A, bp->expanded_B, levelindex);

		omp_unset_lock(&bp->locks[ii - bp->startlevel - 1]);

		control_bit_A_next = control_bit_A;
		control_bit_B_next = control_bit_B;		

		obliv if (levelindex == 0) {
			control_bit_A_next &= bp->advicebits[(ii - bp->startlevel - 1)*2];
			control_bit_B_next &= bp->advicebits[(ii - bp->startlevel - 1)*2];	
		} else {
			control_bit_A_next &= bp->advicebits[(ii - bp->startlevel - 1)*2+1];
			control_bit_B_next &= bp->advicebits[(ii - bp->startlevel - 1)*2+1];
		}
		control_bit_A_next ^= ((obliv bool *)bp->activeblock_A)[0];
		control_bit_B_next ^= ((obliv bool *)bp->activeblock_B)[0];

		//XOR the live branches with Z if they will also be XORed by the offline component
		obliv if (control_bit_A) {
			for (size_t jj = 0; jj < BLOCKSIZE; jj ++) {
				bp->activeblock_A[jj] ^= bp->Z[jj];
			}
		}
		obliv if (control_bit_B) {
			for (size_t jj = 0; jj < BLOCKSIZE; jj ++) {
				bp->activeblock_B[jj] ^= bp->Z[jj];
			}
		}

		control_bit_A = control_bit_A_next;
		control_bit_B = control_bit_B_next;
	}

	for (size_t ii = 1; ii < bp->blockmultiple; ii++) {
		online_prf_double(&bp->activeblock_A[BLOCKSIZE * ii], &bp->activeblock_B[BLOCKSIZE * ii], &bp->activeblock_A[BLOCKSIZE * (ii-1)], &bp->activeblock_B[BLOCKSIZE * (ii-1)], bp->keyL, bp->keyL);
	}
}

void bitpropagator_getblockvector(obliv uint8_t * activeblock_delta, uint8_t * local_output, bool * local_bit_output, bitpropagator * bp, obliv size_t index) {
	bitpropagator_getblockvector_with_callback(activeblock_delta, local_output, local_bit_output, bp, index, NULL, NULL);
}

void bitpropagator_getblockvector_with_callback(obliv uint8_t * activeblock_delta, uint8_t * local_output, bool * local_bit_output, bitpropagator * bp, obliv size_t index, facb_fn cbfn, void* cbpass) {

	//Collect a set of random blocks for the top level
	get_random_bytes(bp->toplevel_local, ((1ll << bp->startlevel) + 1) * BLOCKSIZE);
	ocFromSharedCharN(ocCurrentProto(), bp->toplevel, bp->toplevel_local, ((1ll << bp->startlevel) + 1) * BLOCKSIZE);

	//now send identical blocks for all except the one branch that we're interested in.
	obliv size_t levelindex = index >> (bp->endlevel - bp->startlevel);

	for (size_t ii = 0; ii < (1ll << bp->startlevel); ii++) {
		ocCopyN(&ocCopyChar, &bp->blocktemp_A[ii*BLOCKSIZE], &bp->toplevel[ii * BLOCKSIZE], BLOCKSIZE);
		obliv if (levelindex != ii) {
			ocCopyN(&ocCopyChar, &bp->blocktemp_B[ii*BLOCKSIZE], &bp->toplevel[ii * BLOCKSIZE], BLOCKSIZE);
		} else {
			ocCopyN(&ocCopyChar, bp->activeblock_A, &bp->toplevel[ii * BLOCKSIZE], BLOCKSIZE);
			// ensure the root advice bits are opposite
			((obliv bool *)(&bp->toplevel[(1ll << bp->startlevel)*BLOCKSIZE]))[0] = ~((obliv bool *)bp->activeblock_A)[0];
			ocCopyN(&ocCopyChar, &bp->blocktemp_B[ii*BLOCKSIZE], &bp->toplevel[(1ll << bp->startlevel)*BLOCKSIZE], BLOCKSIZE);
		}
	}
	for (size_t ii = 0; ii < (1ll << bp->startlevel); ii++) for (size_t jj = 0; jj < BLOCKSIZE/sizeof(uint64_t); jj++) revealOblivLLong(&((uint64_t *)(&bp->toplevel_local[ii * BLOCKSIZE]))[jj], ((obliv uint64_t *)(&bp->blocktemp_A[ii * BLOCKSIZE]))[jj], 1);
	for (size_t ii = 0; ii < (1ll << bp->startlevel); ii++) for (size_t jj = 0; jj < BLOCKSIZE/sizeof(uint64_t); jj++) revealOblivLLong(&((uint64_t *)(&bp->toplevel_local[ii * BLOCKSIZE]))[jj], ((obliv uint64_t *)(&bp->blocktemp_B[ii * BLOCKSIZE]))[jj], 2);

	ocCopyN(&ocCopyChar, bp->activeblock_B, &bp->toplevel[(1ll << bp->startlevel)*BLOCKSIZE], BLOCKSIZE);

	bitpropagator_offline_start(bp->bpo, bp->toplevel_local);

	//This is a hack to work around the fact that openmp and obliv-c are incompatible.
	ProtocolDesc pd2;
	splitProtocol(&pd2, ocCurrentProto());
	bitpropagator_offline_parallelizer(bp, bp->bpo, &index, local_output, local_bit_output, &pd2, bitpropagator_traverselevels, bitpropagator_Z_pusher, cbfn, cbpass);
	cleanupProtocol(&pd2);

	//write output
	ocCopyN(&ocCopyChar, activeblock_delta, bp->activeblock_A, BLOCKSIZE*bp->blockmultiple);
	for (size_t ii = 0; ii < (BLOCKSIZE*bp->blockmultiple)/sizeof(uint64_t); ii++) {
		((obliv uint64_t *)activeblock_delta)[ii] ^= ((obliv uint64_t *)bp->activeblock_B)[ii];
	}
}

void bitpropagator_getadvice(obliv bool * advicebits, obliv uint8_t * blocks_A, obliv uint8_t * blocks_B, obliv bool rightblock) {
	advicebits[0] = ((obliv bool *)blocks_A)[0] ^ ((obliv bool *)blocks_B)[0] ^ rightblock ^ 1;
	advicebits[1] = ((obliv bool *)blocks_A)[BLOCKSIZE*8] ^ ((obliv bool *)blocks_B)[BLOCKSIZE*8] ^ rightblock;
}

bitpropagator * bitpropagator_new(size_t size, size_t blockmultiple, uint32_t startlevel) {
	online_expand_init();
	bitpropagator * bp = malloc(sizeof(bitpropagator));
	bp->size = size;
	bp->blockmultiple = blockmultiple;
	bp->endlevel = LOG2LL(size) + (((1ll << LOG2LL(size)) < size)? 1:0);
	bp->startlevel = MIN(startlevel,bp->endlevel-1);
	bp->toplevel = calloc((1ll << bp->startlevel) + 1, BLOCKSIZE * sizeof(obliv uint8_t));
	bp->toplevel_local = malloc(((1ll << bp->startlevel) + 1) * BLOCKSIZE);
	bp->blockzero = calloc(1, BLOCKSIZE * sizeof(obliv uint8_t));
	bp->blocktemp_A = calloc((1ll << bp->startlevel), BLOCKSIZE * sizeof(obliv uint8_t));
	bp->blocktemp_B = calloc((1ll << bp->startlevel), BLOCKSIZE * sizeof(obliv uint8_t));
	bp->activeblock_A = calloc(1, BLOCKSIZE * blockmultiple * sizeof(obliv uint8_t));
	bp->activeblock_B = calloc(1, BLOCKSIZE * blockmultiple * sizeof(obliv uint8_t));
	bp->expanded_A = calloc(2, BLOCKSIZE * sizeof(obliv uint8_t));
	bp->expanded_B = calloc(2, BLOCKSIZE * sizeof(obliv uint8_t));
	bp->Z = calloc((bp->endlevel - bp->startlevel), BLOCKSIZE * sizeof(obliv uint8_t));
	bp->advicebits = calloc((bp->endlevel - bp->startlevel),  2*sizeof(obliv bool));

	//Generator chooses keys so that we don't incur round trips. Since we're semi-honest I guess it's OK? Should probably change it anyway.
	uint8_t * keyL = malloc(KEYSIZE);
	uint8_t * keyR = malloc(KEYSIZE);
	if (ocCurrentParty() == 1) {
		get_random_bytes(keyL, KEYSIZE);
		get_random_bytes(keyR, KEYSIZE);
		for (size_t ii=0; ii< KEYSIZE/sizeof(uint64_t);ii++) ocBroadcastLLong(((uint64_t *)keyL)[ii],1);
		for (size_t ii=0; ii< KEYSIZE/sizeof(uint64_t);ii++) ocBroadcastLLong(((uint64_t *)keyR)[ii],1);
	} else {
		for (size_t ii=0; ii< KEYSIZE/sizeof(uint64_t);ii++) ((uint64_t *)keyL)[ii] = ocBroadcastLLong(NULL,1);
		for (size_t ii=0; ii< KEYSIZE/sizeof(uint64_t);ii++) ((uint64_t *)keyR)[ii] = ocBroadcastLLong(NULL,1);
	}

	online_prf_keyschedule_double(&bp->keyL, &bp->keyR, keyL, keyR);
	bp->bpo = bitpropagator_offline_new(size, blockmultiple, bp->startlevel, keyL, keyR);

	free(keyL);
	free(keyR);

	bp->locks = malloc((bp->endlevel - bp->startlevel) * sizeof(omp_lock_t));
	for (size_t ii = 0; ii < bp->endlevel - bp->startlevel; ii++) {
		omp_init_lock(&bp->locks[ii]);
		omp_set_lock(&bp->locks[ii]);
	}

	return bp;
}

void bitpropagator_free(bitpropagator * bp) {
	free(bp->toplevel);
	free(bp->toplevel_local);
	free(bp->blockzero);
	free(bp->blocktemp_A);
	free(bp->blocktemp_B);
	free(bp->activeblock_A);
	free(bp->activeblock_B);
	free(bp->expanded_A);
	free(bp->expanded_B);
	free(bp->Z);
	free(bp->keyL); free(bp->keyR);
	free(bp->advicebits);
	bitpropagator_offline_free(bp->bpo);

	for (int ii = 0; ii < (bp->endlevel - bp->startlevel); ii++) {
		omp_destroy_lock(&bp->locks[ii]);
	}
	free(bp->locks);

	online_expand_deinit();
	free(bp);
}