#include <stdio.h>
#include <obliv.oh>

#include "big.oh"
#include "montgomery.h"
#include "util.h"

void copy(obyte* dest, obyte* src, unsigned int bytes) {
	for (int ii=0; ii < bytes; ii ++) {
		dest[ii] = src[ii];
	}
}

void oCopy(obyte* dest, obyte* src, unsigned int bytes) obliv {
	for (int ii=0; ii < bytes; ii ++) {
		dest[ii] = src[ii];
	}
}

void twosComplimentInPlace(obyte* x, unsigned int bytes) {
	obliv unsigned char rem = 1;
	for (int ii = 0; ii < bytes; ii ++) {
		obliv unsigned short temp = (x[ii] ^ 0xFF) + rem;
		x[ii] = temp;
		rem = temp >> 8;
	}
}

void oTwosComplimentInPlace(obyte* x, unsigned int bytes) obliv {
	obliv unsigned char rem = 1;
	for (int ii = 0; ii < bytes; ii ++) {
		obliv unsigned short temp = (x[ii] ^ 0xFF) + rem;
		x[ii] = temp;
		rem = temp >> 8;
	}
}

void addInPlace(obyte* x, obyte* y, unsigned int bytes) {
	obliv unsigned char rem = 0;
	for (int jj = 0; jj < bytes; jj ++) {
		obliv unsigned short eresult = x[jj] + y[jj] + rem;
		x[jj] = eresult;
		rem = eresult >> 8;
	}
}

void oAddInPlace(obyte* x, obyte* y, unsigned int bytes) obliv {
	obliv unsigned char rem = 0;
	for (int jj = 0; jj < bytes; jj ++) {
		obliv unsigned short eresult = x[jj] + y[jj] + rem;
		x[jj] = eresult;
		rem = eresult >> 8;
	}
}

void subtractInPlace(obyte* x, obyte* y, unsigned int bytes) {
	twosComplimentInPlace(x, bytes);
	addInPlace(x, y, bytes);
	twosComplimentInPlace(x, bytes);
}

void oSubtractInPlace(obyte* x, obyte* y, unsigned int bytes) obliv {
	oTwosComplimentInPlace(x, bytes);
	oAddInPlace(x, y, bytes);
	oTwosComplimentInPlace(x, bytes);
}

obliv int cmp(obyte* x, obyte* y, unsigned int bytes) {
	obliv int retVal = 0;
	for (int ii = bytes - 1; ii>=0; ii--) {
		obliv if (retVal == 0) {
			obliv if (x[ii] > y[ii]) {
				retVal = 1;
			}
			obliv if (x[ii] < y[ii]) {
				retVal = -1;
			}
		}
	}
	return retVal;
}

obliv int oCmp(obyte* x, obyte* y, unsigned int bytes) obliv {
	obliv int retVal = 0;
	for (int ii = bytes - 1; ii>=0; ii--) {
		obliv if (retVal == 0) {
			obliv if (x[ii] > y[ii]) {
				retVal = 1;
			}
			obliv if (x[ii] < y[ii]) {
				retVal = -1;
			}
		}
	}
	return retVal;
}

obliv unsigned short greaterThanZero(obyte* x, unsigned int bytes) {
	obliv unsigned short result = 0;
	for (int ii = 0; ii < bytes; ii++) {
		obyte thisbyte = x[ii];
		obliv if (thisbyte > 0) {
			result = 1;
		}
	}
	return result;
}

void shiftRightOneBitInPlace(obyte* x, unsigned int bytes) {
	obliv unsigned char rem = 0;
	obliv unsigned char lastRem = 0;
	for (int ii = bytes - 1; ii >= 0; ii--) {
		rem = x[ii] & 1;
		x[ii] = x[ii] >> 1;
		obliv if (lastRem > 0) {
			x[ii] = x[ii] | 0x80;
		}
		lastRem = rem;
	}
}

void oShiftRightOneBitInPlace(obyte* x, unsigned int bytes) obliv {
	obliv unsigned char rem = 0;
	obliv unsigned char lastRem = 0;
	for (int ii = bytes - 1; ii >= 0; ii--) {
		rem = x[ii] & 1;
		x[ii] = x[ii] >> 1;
		obliv if (lastRem > 0) {
			x[ii] = x[ii] | 0x80;
		}
		lastRem = rem;
	}
}

void shiftLeftOneBitInPlace(obyte* x, unsigned int bytes) {
	obliv unsigned char rem = 0;
	obliv unsigned char lastRem = 0;
	for (int ii = 0; ii < bytes; ii++) {
		rem = x[ii] & 0x80;
		x[ii] = x[ii] << 1;
		obliv if (lastRem > 0) {
			x[ii] = x[ii] | 1;
		}
		lastRem = rem;
	}
}

void oShiftLeftOneBitInPlace(obyte* x, unsigned int bytes) obliv {
	obliv unsigned char rem = 0;
	obliv unsigned char lastRem = 0;
	for (int ii = 0; ii < bytes; ii++) {
		rem = x[ii] & 0x80;
		x[ii] = x[ii] << 1;
		obliv if (lastRem > 0) {
			x[ii] = x[ii] | 1;
		}
		lastRem = rem;
	}
}

obliv unsigned int montgomeryFindKForM(obyte* m, unsigned int bytes) {
	obliv unsigned int K = 0;
	unsigned int counter = 1;
	for (int ii = 0; ii<bytes; ii++) {
		obyte thisbyte = m[ii];
		for (int jj = 0; jj < 8; jj++) {
			obliv if ((thisbyte & 0x01) > 0) {
				K = counter;
			}
			thisbyte = thisbyte >> 1;
			counter ++;
		}
	}
	return K;
}

void twoToTheK(obyte* r, obliv unsigned int k, unsigned int bytes) {
	for (int ii = 0; ii < bytes; ii ++ ){
		char pattern = 1;
		r[ii] = 0;
		for (int jj = 0; jj < 8; jj++) {
			obliv if(k == (ii * 8 + jj)) {
				r[ii] = pattern;
			}
			pattern = pattern << 1;
		}
	}
}


// solves result * a + p * (2^k)= 1
obliv unsigned int extendedEuclid(obyte* result, obyte* a, obyte* p) {
	obyte pLocal[2*BYTES];
	obyte u[2*BYTES];
	obyte v[2*BYTES];
	obyte r[2*BYTES];
	obyte s[2*BYTES];
	obyte temp[2*BYTES];
	obliv unsigned int k = 0;
	int ii = 0;
	for (; ii < BYTES; ii++) {
		pLocal[ii] = p[ii];
		u[ii] = p[ii];
		v[ii] = a[ii];
		r[ii] = 0;
		s[ii] = 0;
	}
	for (; ii < 2*BYTES; ii++) {
		pLocal[ii] = 0;
		u[ii] = 0;
		v[ii] = 0;
		r[ii] = 0;
		s[ii] = 0;
	}
	s[0] = 1;

	for (ii = 0; ii < 2*BYTES*8; ii++) {

		obliv if (greaterThanZero(v, 2*BYTES)) {
			k += 1;
			obliv if((u[0] & 1) == 0) {
				oShiftRightOneBitInPlace(u, 2*BYTES);
				oShiftLeftOneBitInPlace(s, 2*BYTES);
			} else {
				obliv if((v[0] & 1) == 0) {
					oShiftRightOneBitInPlace(v, 2*BYTES);
					oShiftLeftOneBitInPlace(r, 2*BYTES);
				} else {
					obliv int compared = oCmp(u, v, 2*BYTES);
					obliv if (compared > 0) {
						oSubtractInPlace(u, v, 2*BYTES);
						oShiftRightOneBitInPlace(u, 2*BYTES);
						oAddInPlace(r, s, 2*BYTES);
						oShiftLeftOneBitInPlace(s, 2*BYTES);
					} else {
						oSubtractInPlace(v, u, 2*BYTES);
						oShiftRightOneBitInPlace(v, 2*BYTES);
						oAddInPlace(s, r, 2*BYTES);
						oShiftLeftOneBitInPlace(r, 2*BYTES);
					}
				}
			}
		}
	}

	// u > 1, no multiplicative inverse exists and the result is wrong!

	obliv int compared = cmp(r, pLocal, 2 * BYTES);
	obliv if (compared > 0) {
		oSubtractInPlace(r, pLocal, 2*BYTES);
	}
	twosComplimentInPlace(r, 2 * BYTES);
	addInPlace(r, pLocal, 2*BYTES);

	for (ii = 0; ii < 2*BYTES*8; ii++) {
		obliv if (ii < k) {
			obliv if((r[0] & 1) == 0) {
				oShiftRightOneBitInPlace(r, 2*BYTES);
			} else {
				oAddInPlace(r, pLocal, 2*BYTES);
				oShiftRightOneBitInPlace(r, 2*BYTES);
			}
		}
	}

	copy(result, r, BYTES);

	return k;
}

void montgomeryReduce(obyte* r, obyte* x, obyte* N) {
	obliv unsigned int k;
	obyte XLocal[2*BYTES];
	obyte NLocal[2*BYTES];
	obyte NPrime[BYTES];

	for (int ii = 0; ii < 2 * BYTES; ii ++) {
		XLocal[ii] = x[ii];
		if (ii < BYTES) {
			NLocal[ii] = N[ii];
		} else {
			NLocal[ii] = 0;
		}
	}

	k = extendedEuclid(NPrime, XLocal, NLocal);

	for (int ii = 0; ii < BYTES; ii ++) {
		for (int jj = 0; jj < 8; jj++) {
			obyte thisBit = (XLocal[ii] >> jj) & 1;
			obyte thisBit2 = thisBit & ((NPrime[ii] >> jj) & 1);
			shiftLeftOneBitInPlace(NLocal, 2*BYTES);
			obliv if (thisBit2 > 0) {
				oAddInPlace(XLocal, NLocal, 2*BYTES);
			}
		}
	}

	for (int ii = 0; ii < BYTES * 8; ii++) {
		obliv if (ii < k) {
			oShiftRightOneBitInPlace(XLocal, 2*BYTES);
		}
	}

	for (int ii = 0; ii < BYTES; ii ++) {
		r[ii] = XLocal[ii];
	}

}

// Schoolbook Multiplication
void modmult(obyte* r, obyte* x, obyte* y, obyte* m) {
	obyte partial_products[BYTES][BYTES + 1];
	obliv unsigned short rem;

	for (int ii = 0; ii < BYTES; ii++) {
		rem = 0;
		for (int jj = 0; jj < BYTES; jj++) {
			obliv unsigned short ex = x[ii];
			obliv unsigned short ey = y[jj];
			obliv unsigned short eresult = ex * ey + rem;
			partial_products[ii][jj] = eresult;
			rem = eresult >> 8;
		}
		partial_products[ii][BYTES] = rem;
	}

	obyte product_premod[2*BYTES];

	for (int ii = 0; ii < 2 * BYTES; ii++) {
		product_premod[ii] = 0;
	}

	for (int ii = 0; ii < BYTES; ii++) {
		rem = 0;
		int jj = 0;
		for (; jj < BYTES + 1; jj ++) {
			obliv unsigned short eresult = product_premod[jj] + partial_products[ii][jj] + rem;
			product_premod[jj] = eresult;
			rem = eresult >> 8;
		}
		for (; jj < 2*BYTES; jj ++) {
			obliv unsigned short eresult = product_premod[jj] + rem;
			product_premod[jj] = eresult;
			rem = eresult >> 8;
		}
	}

	montgomeryReduce(r, product_premod, m);
}

void montgomeryLadder(obyte* x1, obyte* x, obyte* n, obyte* m) {

	for (int ii = 0; ii < BYTES; ii++) {
		x1[ii] = x[ii];
	}
	obyte x2[BYTES];

	modmult(x2, x, x, m);

	for (int ii = 0; ii < BYTES; ii++) {

		obyte nbyte = x[ii];

		for (int jj = 0; jj < 8; jj++) {

			obyte nbit = (nbyte & 1);
			obyte z[BYTES];

			for (int kk = 0; kk < BYTES; kk ++) {
				obliv if (nbit == 0) {
					z[kk] = x1[kk];
				} else {
					z[kk] = x2[kk];
				}
			}

			modmult(x1, x1, z, m);
			modmult(x2, z, x2, m);

			nbyte = nbyte >> 1;

		}
	}
	
}

void readString(obliv char* dest, int n, const char* src,int party)
{
  OblivInputs specs[BYTES];
  int i;
  for(i=0;i<n;++i) setupOblivChar(specs+i,dest+i,src[i]);
  feedOblivInputs(specs,n,party);
}

void montgomeryMain(void* vargs) {
	fprintf(stderr, "Executing Montgomery\n");

	protocolIO *args = vargs;

	obyte x[BYTES];
	obyte n[BYTES];
	obyte m[BYTES];
	obyte r[BYTES];

	for(int ii=0;ii<BYTES;ii++) {
	fprintf(stderr, "%02X ", args->x[BYTES - 1 -ii] & 0xff);
	}
	fprintf(stderr, "\n");
	for(int ii=0;ii<BYTES;ii++) {
	fprintf(stderr, "%02X ", args->m[BYTES - 1 -ii] & 0xff);
	}
	fprintf(stderr, "\n");
	for(int ii=0;ii<BYTES;ii++) {
	fprintf(stderr, "%02X ", args->n[BYTES - 1 -ii] & 0xff);
	}
	fprintf(stderr, "\n");

	feedOblivCharArray(x, args->x, BYTES, 1);
	feedOblivCharArray(m, args->m, BYTES, 1);
	feedOblivCharArray(n, args->n, BYTES, 2);

	//subtract(r, x, n);

	//oAddInPlace(x, n, BYTES);
	//oShiftLeftOneBitInPlace(x, BYTES);
	//shiftRightOneBitInPlace(x, BYTES);
	/*for (int ii = 0; ii < BYTES; ii++) {
		r[ii] = x[ii];
	}*/

	//twoToTheK(r, x[0], BYTES);

	//r[0] = montgomeryFindKForM(n, BYTES);

	obliv int k = extendedEuclid(r, x, n);

	/*obyte longx[2*BYTES];
	int ii =0;
	for (; ii < BYTES; ii++) {
		longx[ii] = x[ii];
	}
	for (; ii < 2*BYTES; ii++) {
		longx[ii] = 0;
	}
	montgomeryReduce(r, x, n);*/

	//montgomeryLadder(r, x, n, m);

	//x[0] = 255;
	//n[0] = 14;
	//r[0] = cmp(x, n, BYTES);

	//r[0] = 0x01;
	//r[1] = 0xFF;
	//r[2] = 0xFF;
	//r[3] = 0xFF;
	//oTwosComplimentInPlace(r, BYTES);

	unsigned int temp;
	revealOblivInt(&temp, k, 0);
	fprintf(stderr, "%d\n", temp);

	for(int ii=0;ii<BYTES;ii++) {
		unsigned char temp;
		revealOblivChar(&temp, r[BYTES - 1 -ii], 0);
		fprintf(stderr, "%02X ", temp & 0xff);
	}
	fprintf(stderr, "\n");

	for(int ii=0;ii<BYTES;ii++) revealOblivChar(args->result + ii,r[ii],0);

	fprintf(stderr,"Yao gate count: %u\n",yaoGateCount());
}