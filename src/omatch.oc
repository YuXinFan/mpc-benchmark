#include "omatch.oh"
#include "oram.oh"
#include "oqueue.oh"
#include "copy.oh"
#include "osort.oh"
#include "shuffle.oh"
#include "waksman.h"
#include "ackutil.h"

static void * element(OcCopy* cpy,void * arr, int x) obliv {
	return x*cpy->eltsize+(char*)arr;
}

static obliv int32_t sign32(obliv int32_t x) {
    return (x>>31) | ((obliv uint32_t)-x >> 31);
}

static obliv int32_t osign32(obliv int32_t x) obliv {
    return (x>>31) | ((obliv uint32_t)-x >> 31);
}

static obliv int64_t sign64(obliv int64_t x) {
    return (x>>63) | ((obliv uint64_t)-x >> 63);
}

static obliv int64_t osign64(obliv int64_t x) obliv {
    return (x>>63) | ((obliv uint64_t)-x >> 63);
}

static void ogs_wStatusFunction(OcCopy * cpy, void * oramBlock, void * extBlock) obliv {
	obliv uint32_t * ob = (obliv uint32_t *) oramBlock;
	obliv uint32_t * eb = (obliv uint32_t *) extBlock;
	obliv bool swap = (ob[0] == 0) | (ob[2] > eb[2]);
	ocSwapCondN(cpy, ob, eb, NULL, &swap, 1);
}

static obliv char ogs_pref_cmp(OcCopy * cpy, void * el1, void * el2) {
	obliv char result;
	obliv if ( ((obliv uint32_t *) el1)[2] <= ((obliv uint32_t *) el2)[2] ) {
		result = -1;
	} else {
		result = 1;
	}
	return result;
}

void ogale_shapley(obliv uint32_t * output, obliv uint32_t * mPrefsRaw, obliv uint32_t * wPrefsRaw, int n) {

	obliv uint32_t * prefs = calloc(2*n*n-n, 5 * sizeof(obliv uint32_t));
	obliv uint32_t * permutation = calloc(2*n*n-n, sizeof(obliv uint32_t));
	obliv uint32_t * permutationInverse = calloc(2*n*n-n, sizeof(obliv uint32_t));
	for (size_t ii = 0; ii < 2*n*n-n; ii++) {
		permutation[ii] = ii;
	}

	OcCopy cpy2 = ocCopyIntN(2);
	OcCopy cpy3 = ocCopyIntN(3);
	OcCopy cpy5 = ocCopyIntN(5);
	oqueue * mQueue = oqueue_new_static(&cpy2, n);

	obliv uint32_t thisPref[5]; // [man index, woman index, man rank, woman rank, pointer to next]
	obliv uint32_t thisMQueue[2]; // [index, pointer to next]
	obliv uint32_t thisWStatus[3]; // [parter index, partner pointer to next, partner rating] 

	OcPermNetwork w = ocPermNetworkRandom(2*n*n-n);
	ocPermNetworkApply(&w,&ocCopyInt,permutation);
	ocPermInverseAssumingPerm(&w, permutationInverse, permutation);

	for (size_t ii = 0; ii < n; ii++) {
		thisPref[0] = ii;
		for (size_t jj = 0; jj < n; jj++) {
			thisPref[1] = jj;
			thisPref[2] = mPrefsRaw[ii * n + jj];
			thisPref[3] = wPrefsRaw[ii * n + jj];

			ocCopy(&cpy5, element(&cpy5, prefs, ii*n+jj), thisPref); 
		}
		osort_batcher(&cpy5, element(&cpy5,prefs,ii * n), n, ogs_pref_cmp);
	}

	for (size_t ii = 0; ii < n; ii++) {
		thisMQueue[0] = ii;
		thisMQueue[1] = permutationInverse[ii * n];
		oqueue_push(mQueue, thisMQueue);
		for (size_t jj = 0; jj < n; jj++) {
			if (jj + 1 < n) {
				prefs[(ii * n + jj) * 5 + 4] = permutationInverse[ii * n + jj + 1];
			} else {
				prefs[(ii * n + jj) * 5 + 4] = -1;
			}
		}
	}

	obliv uint32_t nextDummy = permutationInverse[n*n];

	for (size_t ii = n*n; ii < 2*n*n-n-1; ii++) {
		prefs[ii * 5 + 4] = permutationInverse[ii + 1];
	}

	prefs[(2*n*n-n-1) * 5 + 4] = -1;

	free(permutation);
	free(permutationInverse);

	ocPermNetworkApply(&w,&cpy5,prefs);
	ocPermNetworkCleanup(&w);

	oram * wStatus = oram_new(ORAM_TYPE_AUTO, &cpy3, n);

	obliv uint32_t oPrefPointer;
	uint32_t prefPointer;
	obliv bool dummyAccess = false;

	for (size_t ii = 0; ii < n * n; ii++) {
		obliv if (oqueue_empty(mQueue) == false) {
			oqueue_pop(thisMQueue, mQueue);
			oPrefPointer = thisMQueue[1];
		} else {
			oPrefPointer = nextDummy;
			dummyAccess = true;
		}
			
		revealOblivInt(&prefPointer, oPrefPointer, 0);
		ocCopy(&cpy5, thisPref, element(&cpy5, prefs, prefPointer)); 

		obliv if (dummyAccess == true) {
			nextDummy = thisPref[4];
		} else {
			thisWStatus[0] = thisPref[0] + 1;
			thisWStatus[1] = thisPref[4];
			thisWStatus[2] = thisPref[3];

			oram_apply(wStatus, thisWStatus, ogs_wStatusFunction, thisPref[1]);
			obliv if (thisWStatus[0] != 0) {
				thisWStatus[0] -= 1;
				oqueue_push(mQueue, thisWStatus);
			}
		}
	}

	for (size_t ii = 0; ii < n; ii++) {
		oram_read(thisWStatus, wStatus, ii);
		output[ii] = thisWStatus[0] - 1;
	}

	free(prefs);
	oqueue_free(mQueue);
	oram_free(wStatus);
}


typedef struct oroth_peranson_tentative_match {
	obliv int32_t rid;
	obliv int32_t hrank;
	obliv int32_t rnext;
} oroth_peranson_tentative_match;

typedef struct oroth_peranson_augmented_match {
	obliv int32_t rid;
	obliv int32_t hrank;
	obliv int32_t rnext;
	uint32_t hospital_positions_bound;
} oroth_peranson_augmented_match;

typedef struct oroth_peranson_pairing {
	obliv int32_t rid;
	obliv int32_t rrank;
	obliv int32_t hid;
	obliv int32_t hrank;
	obliv int32_t rnext;
} oroth_peranson_pairing;

static obliv char orp_pref_cmp(OcCopy * cpy, void * el1raw, void * el2raw) {
	oroth_peranson_preference * el1 = ((oroth_peranson_preference *) el1raw);
	oroth_peranson_preference * el2 = ((oroth_peranson_preference *) el2raw);

	return osign64((osign64((obliv int64_t)((obliv uint32_t)el1->rid) - (obliv int64_t)((obliv uint32_t)el2->rid)) << 2) + (osign64((obliv int64_t)((obliv uint32_t)el1->hid) - (obliv int64_t)((obliv uint32_t)el2->hid)) << 1) + (el1->is_h - el2->is_h));
}

static obliv char orp_pair_cmp(OcCopy * cpy, void * el1raw, void * el2raw) {
	oroth_peranson_pairing * el1 = (oroth_peranson_pairing *) el1raw;
	oroth_peranson_pairing * el2 = (oroth_peranson_pairing *) el2raw;
	return osign64((obliv int64_t)((obliv uint32_t)el1->rrank) - (obliv int64_t)((obliv uint32_t)el2->rrank));
}

void orp_hStatusFunction(OcCopy * cpy, void * oramBlock, void * extBlock) obliv {
	obliv uint32_t * thisHospitalData = (obliv uint32_t *) oramBlock;
	oroth_peranson_augmented_match * lowestTentativeMatch = (oroth_peranson_augmented_match *) extBlock;
	oroth_peranson_tentative_match * thisHospitalTentativeMatches = &thisHospitalData[1];
	obliv bool swapThisRound;
	obliv uint32_t temp[3];
	OcCopy cpy;
	~obliv() cpy = ocCopyIntN(3);

	for (size_t jj = 0; jj < lowestTentativeMatch->hospital_positions_bound; jj++) {
		swapThisRound = (jj < thisHospitalData[0] & ((lowestTentativeMatch->hrank < thisHospitalTentativeMatches[jj].hrank) | thisHospitalTentativeMatches[jj].hrank == 0));
		ocSwapCondN(&cpy,&thisHospitalTentativeMatches[jj],lowestTentativeMatch,&temp,&swapThisRound, 1);
	}
}

oroth_peranson_preference_package * oroth_peranson_preference_package_from_shares(oroth_peranson_resident_share * ra, oroth_peranson_resident_share * rb, size_t resident_count, oroth_peranson_hospital_share * ha, oroth_peranson_hospital_share * hb, size_t hospital_count, size_t hospital_positions_bound) {

	size_t r_preferences_bound = 0; size_t h_preferences_bound = 0;
	for (size_t ii = 0; ii < resident_count; ii++) r_preferences_bound = max(max(r_preferences_bound, ra[ii].preferences_bound), rb[ii].preferences_bound);
	for (size_t ii = 0; ii < hospital_count; ii++) h_preferences_bound = max(max(h_preferences_bound, ha[ii].preferences_bound), hb[ii].preferences_bound);

	oroth_peranson_preference_package * result = malloc(sizeof(oroth_peranson_preference_package));
	result->resident_count = resident_count;
	result->hospital_count = hospital_count;
	result->r_preferences_bound = r_preferences_bound;
	result->h_preferences_bound = h_preferences_bound;
	result->r_prefs = calloc(resident_count * r_preferences_bound, sizeof(oroth_peranson_preference));
	result->h_prefs = calloc(hospital_count * h_preferences_bound, sizeof(oroth_peranson_preference));
	result->h_positions_available = calloc(hospital_count, sizeof(obliv uint32_t));
	result->h_positions_bound = hospital_positions_bound;
	
	for (size_t ii = 0; ii < resident_count; ii++) {

		size_t jj = 0;
		for (; jj < min(ra[ii].preferences_bound, rb[ii].preferences_bound); jj++) {
			result->r_prefs[ii * r_preferences_bound + jj].rid = ii;
			result->r_prefs[ii * r_preferences_bound + jj].hid = ra[ii].preferences[jj].id_share ^ rb[ii].preferences[jj].id_share;
			result->r_prefs[ii * r_preferences_bound + jj].is_h = false;
			result->r_prefs[ii * r_preferences_bound + jj].rank = ra[ii].preferences[jj].rank_share ^ rb[ii].preferences[jj].rank_share;
		}
		for (; jj < r_preferences_bound; jj++) {
			result->r_prefs[ii * r_preferences_bound + jj].rid = ii;
			result->r_prefs[ii * r_preferences_bound + jj].hid = -1;
			result->r_prefs[ii * r_preferences_bound + jj].is_h = false;
			result->r_prefs[ii * r_preferences_bound + jj].rank = -1;
		}
	}

	for (size_t ii = 0; ii < hospital_count; ii++) {
		result->h_positions_available[ii] = ha[ii].positions_available_share ^ hb[ii].positions_available_share;

		size_t jj = 0;
		for (; jj < min(ha[ii].preferences_bound, hb[ii].preferences_bound); jj++) {
			result->h_prefs[ii * h_preferences_bound + jj].hid = ii;
			result->h_prefs[ii * h_preferences_bound + jj].rid = ha[ii].preferences[jj].id_share ^ hb[ii].preferences[jj].id_share;
			result->h_prefs[ii * h_preferences_bound + jj].is_h = true;
			result->h_prefs[ii * h_preferences_bound + jj].rank = ha[ii].preferences[jj].rank_share ^ hb[ii].preferences[jj].rank_share;
		}
		for (; jj < h_preferences_bound; jj++) {
			result->h_prefs[ii * h_preferences_bound + jj].rid = -1;
			result->h_prefs[ii * h_preferences_bound + jj].hid = ii;
			result->h_prefs[ii * h_preferences_bound + jj].is_h = true;
			result->h_prefs[ii * h_preferences_bound + jj].rank = -1;
		}
	}

	OcCopy cpy_orppref = ocCopyBoolN(sizeof(oroth_peranson_preference)/sizeof(obliv bool));

	omerge_batcher_multiple(&cpy_orppref, result->h_prefs, h_preferences_bound, h_preferences_bound * hospital_count, orp_pref_cmp);

	return result;
}

void oroth_peranson_preference_package_free(oroth_peranson_preference_package * pkg) {
	free(pkg->r_prefs);
	free(pkg->h_prefs);
	free(pkg->h_positions_available);
}

oroth_peranson_output * oroth_peranson(oroth_peranson_preference_package * pkg) {
	/*
		preferences will be sorted in ID order and have tuples of (ID, ranking) as values. Unranked IDs will be
		omitted. All hospitals/residents will have preferences lists of the same length, but they will not
		necesarily use all available slots in their ranking. (-1, -1) indicates an empty slot.	
	*/
	OcCopy cpy2 = ocCopyIntN(2);
	OcCopy cpy_orppref = ocCopyBoolN(sizeof(oroth_peranson_preference)/sizeof(obliv bool));
	OcCopy cpy_orppair = ocCopyIntN(4);
	OcCopy cpy_orppairfull = ocCopyIntN(5);

	uint32_t resident_count = pkg->resident_count;
	uint32_t hospital_count = pkg->hospital_count;
	uint32_t r_preferences_bound = pkg->r_preferences_bound;
	uint32_t h_preferences_bound = pkg->h_preferences_bound;
	uint32_t h_positions_bound = pkg->h_positions_bound;
	size_t pLen = hospital_count * h_preferences_bound + resident_count * r_preferences_bound;

	oroth_peranson_preference * mergedPrefs = calloc(pLen, sizeof(oroth_peranson_preference));

	ocCopyN(&cpy_orppref, mergedPrefs, pkg->r_prefs, resident_count * r_preferences_bound);
	ocCopyN(&cpy_orppref, &mergedPrefs[resident_count*r_preferences_bound], pkg->h_prefs, hospital_count * h_preferences_bound);
	
	omerge_batcher(&cpy_orppref, mergedPrefs, resident_count*r_preferences_bound, pLen, orp_pref_cmp);

	oqueue * prefQueue = oqueue_new_static(&cpy_orppair, resident_count*r_preferences_bound);

	for (size_t ii = 1; ii < pLen; ii++) {
		obliv if ((mergedPrefs[ii - 1].rid == mergedPrefs[ii].rid) & (mergedPrefs[ii - 1].hid == mergedPrefs[ii].hid) & mergedPrefs[ii].rid >= 0 & mergedPrefs[ii].hid >= 0) {
			//hospital is always sorted last
			oroth_peranson_pairing tempPairing = {
				.rid = mergedPrefs[ii].rid,
				.rrank = mergedPrefs[ii-1].rank,
				.hid = mergedPrefs[ii].hid,
				.hrank = mergedPrefs[ii].rank,
				.rnext = 0
			};
			oqueue_push(prefQueue, &tempPairing);
		}
	}

	free(mergedPrefs);

	oroth_peranson_pairing * preferences = calloc(2 * resident_count * r_preferences_bound - resident_count, sizeof(oroth_peranson_pairing));

	oroth_peranson_pairing nextPairing;
	oroth_peranson_pairing * nextPairingRef = &nextPairing;
	oqueue_pop(&nextPairing, prefQueue);

	for (size_t ii = 0; ii < resident_count; ii ++) {
		for (size_t jj = 0; jj < r_preferences_bound; jj++) {
			obliv if (nextPairing.rid == ii) {
				preferences[ii * r_preferences_bound + jj].rid = nextPairing.rid;
				preferences[ii * r_preferences_bound + jj].rrank = nextPairing.rrank;
				preferences[ii * r_preferences_bound + jj].hid = nextPairing.hid;
				preferences[ii * r_preferences_bound + jj].hrank = nextPairing.hrank;
				obliv if (oqueue_empty(prefQueue)) {
					nextPairing.rid = -1;
				} else {
					oqueue_pop(nextPairingRef, prefQueue);
				}
			} else {
				preferences[ii * r_preferences_bound + jj].rid = -1;
				preferences[ii * r_preferences_bound + jj].rrank = -1;
				preferences[ii * r_preferences_bound + jj].hid = -1;
				preferences[ii * r_preferences_bound + jj].hrank = -1;
			}
		}
	}

	for (size_t ii = 0; ii < resident_count; ii ++) {
		osort_batcher(&cpy_orppairfull, element(&cpy_orppairfull,preferences,ii * r_preferences_bound), r_preferences_bound, orp_pair_cmp);
	}

	oqueue_free(prefQueue);

	oroth_peranson_pairing thisPref;
	obliv uint32_t oPrefPointer;

	obliv uint32_t * startingLinks = calloc(resident_count, sizeof(obliv uint32_t));
	obliv uint32_t * permutation = calloc(2 * resident_count * r_preferences_bound - resident_count, sizeof(obliv uint32_t));
	obliv uint32_t * permutationInverse = calloc(2 * resident_count * r_preferences_bound - resident_count, sizeof(obliv uint32_t));
	for (size_t ii = 0; ii < 2 * resident_count * r_preferences_bound - resident_count; ii++) {
		permutation[ii] = ii;
	}

	OcPermNetwork w = ocPermNetworkRandom(2 * resident_count * r_preferences_bound - resident_count);
	ocPermNetworkApply(&w,&ocCopyInt,permutation);
	ocPermInverseAssumingPerm(&w, permutationInverse, permutation);

	for (size_t ii = 0; ii < resident_count; ii++) {
		startingLinks[ii] = permutationInverse[ii * r_preferences_bound];
		for (size_t jj = 0; jj < r_preferences_bound; jj++) {
			if (jj + 1 < r_preferences_bound) {
				obliv if (preferences[(ii * r_preferences_bound + jj + 1)].rid == -1) {
					preferences[(ii * r_preferences_bound + jj)].rnext = -1;
				} else {
					preferences[(ii * r_preferences_bound + jj)].rnext = permutationInverse[ii * r_preferences_bound + jj + 1];
				}
			} else {
				preferences[(ii * r_preferences_bound + jj)].rnext = -1;
			}
		}
	}

	oqueue * rQueueUnconsidered = oqueue_static_from_array(&ocCopyInt, resident_count, startingLinks);
	free(startingLinks);

	obliv uint32_t nextDummy = permutationInverse[resident_count * r_preferences_bound];

	for (size_t ii = resident_count * r_preferences_bound; ii < 2 * resident_count * r_preferences_bound - resident_count - 1; ii++) {
		preferences[ii].rnext = permutationInverse[ii + 1];
	}

	preferences[2 * resident_count * r_preferences_bound - resident_count - 1].rnext = -1;

	free(permutation);
	free(permutationInverse);


	ocPermNetworkApply(&w,&cpy_orppairfull,preferences);
	ocPermNetworkCleanup(&w);

	oroth_peranson_pairing nextPotentialPairing;

	uint32_t prefPointer;
	obliv bool solutionFound = false;

	OcCopy cpyhpt = ocCopyIntN((sizeof(oroth_peranson_tentative_match) * h_positions_bound) / sizeof(obliv uint32_t) + 1);
	obliv uint32_t * hospitalTentativeMatchesSeed = calloc(hospital_count, sizeof(oroth_peranson_tentative_match) * h_positions_bound + sizeof(obliv uint32_t));
	for (size_t ii = 0; ii < hospital_count; ii ++) {
		hospitalTentativeMatchesSeed[ii * (sizeof(oroth_peranson_tentative_match) * h_positions_bound / sizeof(obliv uint32_t) + 1)] = pkg->h_positions_available[ii];
	}
	oram * hospitalTentativeMatches = oram_from_array(ORAM_TYPE_AUTO, &cpyhpt, hospital_count, hospitalTentativeMatchesSeed);
	free(hospitalTentativeMatchesSeed);

	oqueue_pop(&oPrefPointer, rQueueUnconsidered);

	for (size_t ii = 0; ii < resident_count * r_preferences_bound; ii++) {
		revealOblivInt(&prefPointer, oPrefPointer, 0);
		ocCopy(&cpy_orppairfull, &nextPotentialPairing, element(&cpy_orppairfull, preferences, prefPointer));

		obliv if (solutionFound) {
			oPrefPointer = nextPotentialPairing.rnext;
		} else {
			oroth_peranson_augmented_match lowestTentativeMatch;
			lowestTentativeMatch.hospital_positions_bound = h_positions_bound;
			lowestTentativeMatch.rid = nextPotentialPairing.rid + 1;
			lowestTentativeMatch.hrank = nextPotentialPairing.hrank + 1;
			lowestTentativeMatch.rnext = nextPotentialPairing.rnext;

			oram_apply(hospitalTentativeMatches, &lowestTentativeMatch, orp_hStatusFunction, nextPotentialPairing.hid);

			obliv if (lowestTentativeMatch.rid != 0 & lowestTentativeMatch.rnext >= 0) {
				oPrefPointer = lowestTentativeMatch.rnext;
			} else obliv if (oqueue_empty(rQueueUnconsidered) == false) {
				obliv bool queueworked = oqueue_pop(&oPrefPointer, rQueueUnconsidered);
			} else {
				solutionFound = true;
				oPrefPointer = nextDummy;
			}
		}
	}

	oqueue_free(rQueueUnconsidered);
	free(preferences);

	obliv uint32_t * thisHospitalData = calloc(1, sizeof(oroth_peranson_tentative_match) * h_positions_bound + sizeof(obliv uint32_t));
	oroth_peranson_tentative_match * thisHospitalTentativeMatches = &thisHospitalData[1];

	oroth_peranson_output * output = calloc(1, sizeof(oroth_peranson_output));
	output->hospitals = calloc(hospital_count, sizeof(oroth_peranson_hospital_output));
	output->hospital_count = hospital_count;
	output->positions_bound = h_positions_bound;

	for (size_t ii = 0; ii < hospital_count; ii++) {
		output->hospitals[ii].matches = calloc(h_positions_bound, sizeof(obliv int32_t));
		oram_read(thisHospitalData, hospitalTentativeMatches, ii);
		for (size_t jj = 0; jj < h_positions_bound; jj++) {
			output->hospitals[ii].matches[jj] = thisHospitalTentativeMatches[jj].rid - 1;
		}
	}

	oram_free(hospitalTentativeMatches);
	free(thisHospitalData);
	return output;
}

void oroth_peranson_output_free(oroth_peranson_output * output) {
	free(output->hospitals);
}