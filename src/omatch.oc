#include "omatch.oh"
#include "oram.oh"
#include "oqueue.oh"
#include "copy.oh"
#include "osort.oh"
#include "shuffle.oh"
#include "waksman.h"

#include <stdio.h>

static void * element(OcCopy* cpy,void * arr, int x) obliv {
	return x*cpy->eltsize+(char*)arr;
}

void wStatusFunction(OcCopy * cpy, void * oramBlock, void * extBlock) obliv {
	obliv uint32_t * ob = (obliv uint32_t *) oramBlock;
	obliv uint32_t * eb = (obliv uint32_t *) extBlock;
	obliv uint32_t * temp;
	~obliv(en) {
		temp = calloc(1, cpy->eltsize);
		memcpy(temp, ob, cpy->eltsize);
	}
	obliv if ((ob[0] == 0) | (ob[2] > eb[2])) {
		ocCopy(cpy, ob, eb);
		ocCopy(cpy, eb, temp);
	}
	~obliv(en) {
		free(temp);
	}
}

obliv char pref_cmp(OcCopy * cpy, void * el1, void * el2) {
	obliv char result;
	obliv if ( ((obliv uint32_t *) el1)[2] <= ((obliv uint32_t *) el2)[2] ) {
		result = -1;
	} else {
		result = 1;
	}
	return result;
}

void ogale_shapley(obliv uint32_t * output, obliv uint32_t * mPrefsRaw, obliv uint32_t * wPrefsRaw, int n) {

	obliv uint32_t * prefs = calloc(2*n*n-n, 5 * sizeof(obliv uint32_t));
	obliv uint32_t * permutation = calloc(2*n*n-n, sizeof(obliv uint32_t));
	obliv uint32_t * permutationInverse = calloc(2*n*n-n, sizeof(obliv uint32_t));
	for (size_t ii = 0; ii < 2*n*n-n; ii++) {
		permutation[ii] = ii;
	}

	OcCopy cpy2 = ocCopyIntN(2);
	OcCopy cpy3 = ocCopyIntN(3);
	OcCopy cpy5 = ocCopyIntN(5);
	oqueue * mQueue = oqueue_new_static(&cpy2, n);

	obliv uint32_t thisPref[5]; // [man index, woman index, man rank, woman rank, pointer to next]
	obliv uint32_t thisMQueue[2]; // [index, pointer to next]
	obliv uint32_t thisWStatus[3]; // [parter index, partner pointer to next, partner rating] 

	OcPermNetwork w = ocPermNetworkRandom(2*n*n-n);
	ocPermNetworkApply(&w,&ocCopyInt,permutation);
	ocPermInverseAssumingPerm(&w, permutationInverse, permutation);

	for (size_t ii = 0; ii < n; ii++) {
		thisPref[0] = ii;
		for (size_t jj = 0; jj < n; jj++) {
			thisPref[1] = jj;
			thisPref[2] = mPrefsRaw[ii * n + jj];
			thisPref[3] = wPrefsRaw[ii * n + jj];

			ocCopy(&cpy5, element(&cpy5, prefs, ii*n+jj), thisPref); 
		}
		osort_batcher(&cpy5, element(&cpy5,prefs,ii * n), n, pref_cmp);
	}

	for (size_t ii = 0; ii < n; ii++) {
		thisMQueue[0] = ii;
		thisMQueue[1] = permutationInverse[ii * n];
		oqueue_push(mQueue, thisMQueue);
		for (size_t jj = 0; jj < n; jj++) {
			if (jj + 1 < n) {
				prefs[(ii * n + jj) * 5 + 4] = permutationInverse[ii * n + jj + 1];
			} else {
				prefs[(ii * n + jj) * 5 + 4] = -1;
			}
		}
	}

	obliv uint32_t nextDummy = permutationInverse[n*n];

	for (size_t ii = n*n; ii < 2*n*n-n-1; ii++) {
		prefs[ii * 5 + 4] = permutationInverse[ii + 1];
	}

	prefs[(2*n*n-n-1) * 5 + 4] = -1;

	free(permutation);
	free(permutationInverse);

	ocPermNetworkApply(&w,&cpy5,prefs);
	ocPermNetworkCleanup(&w);

	oram * wStatus = oram_new(ORAM_TYPE_AUTO, &cpy3, n);

	obliv uint32_t oPrefPointer;
	uint32_t prefPointer;
	obliv bool dummyAccess = false;

	for (size_t ii = 0; ii < n * n; ii++) {
		obliv if (oqueue_empty(mQueue) == false) {
			oqueue_pop(thisMQueue, mQueue);
			oPrefPointer = thisMQueue[1];
		} else {
			oPrefPointer = nextDummy;
			dummyAccess = true;
		}
			
		revealOblivInt(&prefPointer, oPrefPointer, 0);
		ocCopy(&cpy5, thisPref, element(&cpy5, prefs, prefPointer)); 

		obliv if (dummyAccess == true) {
			nextDummy = thisPref[4];
		} else {
			thisWStatus[0] = thisPref[0] + 1;
			thisWStatus[1] = thisPref[4];
			thisWStatus[2] = thisPref[3];

			oram_apply(wStatus, thisWStatus, wStatusFunction, thisPref[1]);
			obliv if (thisWStatus[0] != 0) {
				thisWStatus[0] -= 1;
				oqueue_push(mQueue, thisWStatus);
			}
		}
	}

	for (size_t ii = 0; ii < n; ii++) {
		oram_read(thisWStatus, wStatus, ii);
		output[ii] = thisWStatus[0] - 1;
	}

	free(prefs);
	oqueue_free(mQueue);
	oram_free(wStatus);
}