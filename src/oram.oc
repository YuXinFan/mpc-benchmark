#include "oram.oh"

void oram_init(oram* o, size_t size) {
	o->size = size;
	o->data = malloc(sizeof(oram_base) * o->size);
}

void oram_expand(oram* o, size_t new_size) {
	if (new_size < o->size) return;

	oram_base * old_data = o->data;
	o->data = malloc(sizeof(oram_base) * new_size);
	memcpy(o->data, old_data, sizeof(oram_base) * o->size);
	o->size = new_size;
	free(old_data);
}

void oram_free(oram* o) {
	free(o->data);
	o->size = 0;
	o->data = NULL;
}

obliv bool oram_read(oram_base * output, oram * o, obliv size_t index) {
	obliv bool success = false;
	for (size_t ii = 0; ii < o->size; ii++) {
		obliv if (ii == index) {
			*output = o->data[ii];
			success = true;
		}
	}
	return success;
}

obliv bool oram_read_obliv(oram_base * output, oram * o, obliv size_t index) obliv {
	obliv bool success = false;
	for (size_t ii = 0; ii < o->size; ii++) {
		obliv if (ii == index) {
			*output = o->data[ii];
			success = true;
		}
	}
	return success;
}

obliv bool oram_write(oram * o, oram_base input, obliv size_t index) {
	obliv bool success = false;
	for (size_t ii = 0; ii < o->size; ii++) {
		obliv if (ii == index) {
			o->data[ii] = input;
			success = true;
		}
	}
	return success;
}

obliv bool oram_write_obliv(oram * o, oram_base input, obliv size_t index) obliv {
	obliv bool success = false;
	for (size_t ii = 0; ii < o->size; ii++) {
		obliv if (ii == index) {
			o->data[ii] = input;
		}
	}
	return success;
}
