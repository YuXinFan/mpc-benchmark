#include <stdint.h>

#include "util.h"
#include "obig.oh"

#define IS_BIG_ENDIAN (*(uint16_t *)"\0\xff" < 0x100)

/* Utility functions to be used only internally */

uint32_t ceildiv(uint32_t dividend, uint32_t divisor) {
	return (dividend + divisor - 1) / divisor; // ceil(dividend/divisor)
}

obliv bool obyte_msb_is_one(obliv uint8_t x) obliv {
	obliv bool result;
	//big_digit pattern = ~((big_digit)-1 >> 1);
	obliv if (x & 0x80 == 0) {
		result = 0;
	} else {
		result = 1;
	}
	return result;
}


/* memory management */

void obig_init(obig* x, size_t bytes) {
	x->digits = bytes; //ceildiv(bytes,sizeof(big_digit));
	x->data = malloc(sizeof(obliv uint8_t) * x->digits);
}

void obig_free(obig* x) {
	free(x->data);
	x->digits = 0;
	x->data = NULL;
}

void obig_resize(obig* x, size_t bytes) {
	obig temp;
	temp.digits = bytes; //ceildiv(bytes, sizeof(big_digit));
	temp.data = malloc(sizeof(obliv uint8_t) * temp.digits);

	obig_copy(&temp, *x);

	free(x->data);
	x->digits = temp.digits;
	x->data = temp.data;
}

void obig_resize_signed(obig* x, size_t bytes);
void obig_match_sizes(obig* x, obig* y);
void obig_match_sizes_signed(obig* x, obig* y);

void obig_copy(obig* out, obig in) obliv {
	for (size_t ii = 0; ii < out->digits; ii++) {
		if (ii < in.digits) {
			out->data[ii] = in.data[ii];
		} else {
			out->data[ii] = 0;
		}
	}
}

void obig_copy_signed(obig* out, obig in) obliv {
	if (out->digits > in.digits) {
		obliv bool inputIsNegative = obyte_msb_is_one(in.data[in.digits-1]);
		for (size_t ii = 0; ii < out->digits; ii++) {
			if (ii < in.digits) {
				out->data[ii] = in.data[ii];
			} else {
				// sign extend with MSB of input
				obliv if(inputIsNegative > 0) {
					out->data[ii] = -1;	
				} else {
					out->data[ii] = 0;
				}
			}
		}
	} else {
		for (size_t ii = 0; ii < out->digits; ii++) {
			out->data[ii] = in.data[ii];
		}
	}
}

/* convenience setters */

void obig_zero(obig* x) obliv {
	for (size_t ii = 0; ii < x->digits; ii++) {
		x->data[ii] = 0;
	}
}

void obig_one(obig* x) obliv {
	x->data[0] = 1;
	for (size_t ii = 1; ii < x->digits; ii++) {
		x->data[ii] = 0;
	}
}

void obig_set_onative(obig* x, obliv uint64_t y) obliv {
	for (size_t ii = 0; ii < x->digits; ii++) {
		if (ii < 16) {
			x->data[ii] = y >> (8 * ii);
		} else {
			x->data[ii] = 0;
		}
	}
}

void obig_set_onative_signed(obig* x, obliv int64_t y) obliv {
	for (size_t ii = 0; ii < x->digits; ii++) {
		if (ii < 16) {
			x->data[ii] = y >> (8 * ii);
		} else {
			obliv if (y < 0) {
				x->data[ii] = 0xFF;
			} else {
				x->data[ii] = 0;
			}
		}
	}
}

void obig_set_pointed(obig* x, void* p, size_t s) obliv {
	for (size_t ii = 0; ii < x->digits; ii++) {
		if (ii < s) {
			if (IS_BIG_ENDIAN) {
				x->data[x->digits - 1 - ii] = ((uint8_t*) p)[ii];
			} else {
				x->data[ii] = ((uint8_t*) p)[ii];
			}
		} else {
			x->data[ii] = 0;
		}
	}
}

/* comparators */

obliv bool obig_eq(obig x, obig y) obliv;
obliv bool obig_eq_signed(obig x, obig y) obliv;
obliv bool obig_gt(obig x, obig y) obliv;
obliv bool obig_gt_signed(obig x, obig y) obliv;
obliv bool obig_lt(obig x, obig y) obliv;
obliv bool obig_lt_signed(obig x, obig y) obliv;
obliv bool obig_gte(obig x, obig y) obliv;
obliv bool obig_gte_signed(obig x, obig y) obliv;
obliv bool obig_lte(obig x, obig y) obliv;
obliv bool obig_lte_signed(obig x, obig y) obliv;

obliv bool obig_gtz(obig x) obliv {
	obliv bool result = 0;
	for (size_t ii = 0; ii < x.digits; ii++) {
		obliv if (x.data[ii] > 0) {
			result = 1;
		}
	}
	return result;
}

obliv bool obig_gtz_signed(obig x) obliv {
	return (~(obig_ltz_signed(x) | obig_eqz(x))) & 1;
}

obliv bool obig_ltz_signed(obig x) obliv {
	return obyte_msb_is_one(x.data[x.digits - 1]);
}

obliv bool obig_eqz(obig x) obliv {
	obliv bool result = 1;
	for (size_t ii = 0; ii < x.digits; ii++) {
		obliv if (x.data[ii] != 0) {
			result = 0;
		}
	}
	return result;
}

obliv int8_t obig_cmp(obig x, obig y) obliv;
obliv int8_t obig_cmp_signed(obig x, obig y) obliv;

/* nondestructive elementary math */

void obig_shl1(obig* out, obig x) obliv {
	obliv uint8_t rem = 0;
	obliv uint8_t lastRem = 0;
	for (size_t ii = 0; ii < out->digits; ii++) {
		if (ii < x.digits) {
			rem = x.data[ii] & 0x80;
			obliv if (lastRem > 0) {
				out->data[ii] = (x.data[ii] << 1) | 1;
			} else {
				out->data[ii] = x.data[ii] << 1;
			}
			lastRem = rem;
		} else if (ii == x.digits) {
			obliv if (lastRem > 0) {
				out->data[ii] = 1;
			} else {
				out->data[ii] = 0;
			}
		} else {
			out->data[ii] = 0;
		}
	}
}

void obig_shl_native(obig* out, obig x, uint32_t y) obliv {
	if (y > 0) {
		obig_shl1(out, x);
	} else {
		obig_copy(out, x);
	}
	for (size_t ii = 1; ii < y; ii ++) {
		obig_shl1(out, *out);
	}
}

void obig_shl_onative(obig* out, obig x, obliv uint32_t y) obliv {
	obig_copy(out, x);
	for (size_t ii = 0; ii < x.digits; ii++) {
		obliv if (ii < y) {
			obig_shl1(out, *out);
		}
	}
}

void obig_shr1(obig* out, obig x) obliv {
	obliv uint8_t rem = 0;
	obliv uint8_t lastRem = 0;
	for (size_t ii = out->digits - 1; ii >= 0; ii--) {
		if (ii >= x.digits) {
			out->data[ii] = 0;
		} else {
			rem = x.data[ii] & 1;
			obliv if (lastRem > 0) {
				out->data[ii] = (x.data[ii] >> 1) | 0x80;
			} else {
				out->data[ii] = (x.data[ii] >> 1);
			}
			lastRem = rem;
		}
	}
}

void obig_shr_native(obig* out, obig x, uint32_t y) obliv {
	if (y > 0) {
		obig_shr1(out, x);
	} else {
		obig_copy(out, x);
	}
	for (uint32_t ii = 1; ii < y; ii ++) {
		obig_shr1(out, *out);
	}
}

void obig_shr_onative(obig* out, obig x, obliv uint32_t y) obliv {
	obig_copy(out, x);
	for (size_t ii = 0; ii < x.digits; ii++) {
		obliv if (ii < y) {
			obig_shr1(out, *out);
		}
	}
}

void obig_neg(obig* out, obig x) obliv {
	obliv uint8_t rem = 1;
	for (size_t ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits) {
			obliv uint16_t temp = (x.data[ii] ^ 0xFF) + rem;
			out->data[ii] = temp;
			rem = temp >> 8;
		} else {
			//obliv if (obyte_msb_is_one(x.data[x.digits - 1]) == 0) {
				obliv uint16_t temp = 0xFF + rem;
				out->data[ii] = temp;
				rem = temp >> 8;
			//} else {
			//	obliv uint16_t temp = 0x00 + rem;
			//	x.data[ii] = temp;
			//	rem = temp >> 8;
			//}
		}
	}
}

void obig_add(obig* out, obig x, obig y) obliv {
	obliv uint8_t rem = 0;
	for (size_t ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits && ii < y.digits) {
			obliv uint16_t eresult = x.data[ii] + y.data[ii] + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		} else if (ii < x.digits) {
			obliv uint16_t eresult = x.data[ii] + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		} else if (ii < y.digits) {
			obliv uint16_t eresult = y.data[ii] + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		} else if ((ii >= x.digits && ii == y.digits) || (ii >= y.digits && ii == x.digits)) {
			out->data[ii] = rem;
		} else {
			out->data[ii] = 0;
		}
	}
}

void obig_sub(obig* out, obig x, obig y) obliv {
	obliv uint8_t rem = 1;
	for (size_t ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits && ii < y.digits) {
			obliv uint16_t eresult = x.data[ii] + (y.data[ii] ^ 0xFF) + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		} else if (ii < x.digits) {
			obliv uint16_t eresult = x.data[ii] + 0xFF + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		} else if (ii < y.digits) {
			obliv uint16_t eresult = (y.data[ii] ^ 0xFF) + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		} else {
			obliv uint16_t eresult = 0xFF + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		}
	}
}




obliv uint8_t kcm_add_with_carry(obliv uint8_t *x,obliv uint8_t *y,obliv uint8_t *z,size_t n) obliv {
	obliv uint8_t rem = 0;
	for (size_t ii = 0; ii < n; ii ++) {
		obliv uint16_t eresult = x[ii] + y[ii] + rem;
		z[ii] = eresult;
		rem = eresult >> 8;
	}
	return rem;
}

obliv uint8_t kcm_inc(obliv uint8_t *x,obliv uint8_t *z,size_t n) obliv {
	obliv uint8_t rem = 0;
	for (size_t ii = 0; ii < n; ii ++) {
		obliv uint16_t eresult = z[ii] + x[ii] + rem;
		z[ii] = eresult;
		rem = eresult >> 8;
	}
	return rem;
}

obliv uint8_t kcm_dec(obliv uint8_t *y,obliv uint8_t *z,size_t n) obliv {
	obliv uint8_t rem = 0;
	for (size_t ii = 0; ii < n; ii ++) {
		obliv uint16_t eresult = z[ii] - y[ii] - rem;
		z[ii] = eresult;
		rem = (eresult >> 8) & 1;
	}
	return rem;
}

void kcm_comba(size_t n,obliv uint8_t *t,obliv uint8_t *x,obliv uint8_t *y,obliv uint8_t *z) obliv {
	obliv uint16_t res = y[0] * x[0];
	z[0] = res;
	z[1] = res >> 8;
}

#define COMBA_THRESHOLD 1
void kcm(size_t n,obliv uint8_t *t,obliv uint8_t *x,obliv uint8_t *y,obliv uint8_t *z) obliv {
	if (n % 2 != 0) {
		kcm_comba(n,t,x,y,z);
		return;
	}

	size_t nd2 = n/2;
	size_t m = n/COMBA_THRESHOLD;
	size_t md2 = m/2;

	obliv uint8_t c1=kcm_add_with_carry(x,&x[nd2],z,md2);
    obliv uint8_t c2=kcm_add_with_carry(y,&y[nd2],&z[nd2],md2);

    obliv uint8_t c=0;
    kcm(nd2,&t[n],z,&z[nd2],t);
    obliv if (c1 > 0) c+=kcm_inc(&z[nd2],&t[nd2],md2);
    obliv if (c2 > 0) c+=kcm_inc(z,&t[nd2],md2);
    obliv if ((c1 & c2) > 0) c++;

    kcm(nd2,&t[n],x,y,z);
    c-=kcm_dec(z,t,m);           /* subtract a0.b0 */

    kcm(nd2,&t[n],&x[nd2],&y[nd2],&z[n]);
    c-=kcm_dec(&z[n],t,m);       /* subtract a1.b1 */

    c+=kcm_inc(t,&z[nd2],m);    /* combine results */

    size_t ii=n+nd2;
    z[ii]+=c;
    obliv bool keepcarrying = true;
    for (ii++;ii<n*2;ii++) { /* propagate carries - very rare */
    	obliv if (z[n+nd2]<c & keepcarrying & ((ii == n+nd2 + 1) | (z[ii-1]==0))) {
    		z[ii]++;
    	} else {
    		keepcarrying = false;
    	}
    }
}

void obig_mul(obig* out, obig x, obig y) obliv {

	~obliv(en) {
		size_t indigits = max(x.digits, y.digits);
		obliv uint8_t * temp = calloc(indigits * 2, sizeof(obliv uint8_t));

		obliv uint8_t * x2;
		obliv uint8_t * y2;
		obliv uint8_t * z;

		if (x.digits < indigits) {
			x2 = calloc(indigits, sizeof(obliv uint8_t));
			size_t ii = 0;
			for (; ii < x.digits; ii++) {
				x2[ii] = x.data[ii];
			}
		} else {
			x2 = x.data;
		}

		if (y.digits < indigits) {
			y2 = calloc(indigits, sizeof(obliv uint8_t));
			size_t ii = 0;
			for (; ii < y.digits; ii++) {
				y2[ii] = y.data[ii];
			}
		} else {
			y2 = y.data;
		}

		if (out->digits < indigits * 2) {
			z = calloc(indigits * 2, sizeof(obliv uint8_t));
		} else {
			z = out->data;
		}

		obliv if (en) kcm(indigits,temp, x2, y2, z);

		if (x.digits < indigits) {
			free(x2);
		}
		if (y.digits < indigits) {
			free(y2);
		}
		if (out->digits < indigits * 2) {
			for (size_t ii = 0; ii < out->digits; ii++) {
				out->data[ii] = z[ii];
			}
			free(z);
		} else {
			for (size_t ii = indigits * 2; ii < out->digits; ii++) {
				out->data[ii] = 0;
			}
		}

		free(temp);
	}
}




void obig_not(obig* out, obig x) obliv {
	for (size_t ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits) {
			out->data[ii] = ~x.data[ii];
		} else {
			out->data[ii] = 0xFF;
		}
	}
}

void obig_and(obig* out, obig x, obig y) obliv {
	for (size_t ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits && ii < y.digits) {
			out->data[ii] = x.data[ii] & y.data[ii];
		} else {
			out->data[ii] = 0;
		}
	}
}

void obig_or(obig* out, obig x, obig y) obliv {
	for (size_t ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits && ii < y.digits) {
			out->data[ii] = x.data[ii] | y.data[ii];
		} else if (ii < x.digits) {
			out->data[ii] = x.data[ii];
		} else if (ii < y.digits) {
			out->data[ii] = y.data[ii];
		} else {
			out->data[ii] = 0;
		}
	}
}

void obig_xor(obig* out, obig x, obig y) obliv {
	for (size_t ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits && ii < y.digits) {
			out->data[ii] = x.data[ii] ^ y.data[ii];
		} else if (ii < x.digits) {
			out->data[ii] = x.data[ii];
		} else if (ii < y.digits) {
			out->data[ii] = y.data[ii];
		} else {
			out->data[ii] = 0;
		}
	}
}	