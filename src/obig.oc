#include <stdint.h>

#include "util.h"
#include "obig.oh"

#define IS_BIG_ENDIAN (*(uint16_t *)"\0\xff" < 0x100)

/* Utility functions to be used only internally */

uint32_t ceildiv(uint32_t dividend, uint32_t divisor) {
	return (dividend + divisor - 1) / divisor; // ceil(dividend/divisor)
}

obliv bool obyte_msb_is_one(obliv uint8_t x) obliv {
	obliv bool result;
	//big_digit pattern = ~((big_digit)-1 >> 1);
	obliv if ((x & 0x80) == 0) {
		result = false;
	} else {
		result = true;
	}
	return result;
}


/* memory management */

void obig_init(obig* x, size_t bytes) {
	x->digits = bytes; //ceildiv(bytes,sizeof(big_digit));
	x->data = calloc(x->digits, sizeof(obliv uint8_t));
}

void obig_free(obig* x) {
	free(x->data);
	x->digits = 0;
	x->data = NULL;
}

void obig_resize(obig* x, size_t bytes) {
	obig temp;
	temp.digits = bytes; //ceildiv(bytes, sizeof(big_digit));
	temp.data = calloc(temp.digits, sizeof(obliv uint8_t));

	obig_copy(&temp, *x);

	free(x->data);
	x->digits = temp.digits;
	x->data = temp.data;
}

void obig_resize_signed(obig* x, size_t bytes);
void obig_match_sizes(obig* x, obig* y);
void obig_match_sizes_signed(obig* x, obig* y);

void obig_copy(obig* out, obig in) obliv {
	if (out->data != in.data) {
		for (size_t ii = 0; ii < out->digits; ii++) {
			if (ii < in.digits) {
				out->data[ii] = in.data[ii];
			} else {
				out->data[ii] = 0;
			}
		}
	}
}

void obig_copy_signed(obig* out, obig in) obliv {
	if (out->data != in.data) {
		if (out->digits > in.digits) {
			obliv bool inputIsNegative = obyte_msb_is_one(in.data[in.digits-1]);
			for (size_t ii = 0; ii < out->digits; ii++) {
				if (ii < in.digits) {
					out->data[ii] = in.data[ii];
				} else {
					// sign extend with MSB of input
					obliv if(inputIsNegative > 0) {
						out->data[ii] = -1;	
					} else {
						out->data[ii] = 0;
					}
				}
			}
		} else {
			for (size_t ii = 0; ii < out->digits; ii++) {
				out->data[ii] = in.data[ii];
			}
		}
	}
}

/* convenience setters */

void obig_zero(obig* x) obliv {
	for (size_t ii = 0; ii < x->digits; ii++) {
		x->data[ii] = 0;
	}
}

void obig_one(obig* x) obliv {
	x->data[0] = 1;
	for (size_t ii = 1; ii < x->digits; ii++) {
		x->data[ii] = 0;
	}
}

void obig_set_onative(obig* x, obliv uint64_t y) obliv {
	for (size_t ii = 0; ii < x->digits; ii++) {
		if (ii < 16) {
			x->data[ii] = y >> (8 * ii);
		} else {
			x->data[ii] = 0;
		}
	}
}

void obig_set_onative_signed(obig* x, obliv int64_t y) obliv {
	for (size_t ii = 0; ii < x->digits; ii++) {
		if (ii < 16) {
			x->data[ii] = y >> (8 * ii);
		} else {
			obliv if (y < 0) {
				x->data[ii] = 0xFF;
			} else {
				x->data[ii] = 0;
			}
		}
	}
}

void obig_set_pointed(obig* x, void* p, size_t s) obliv {
	for (size_t ii = 0; ii < x->digits; ii++) {
		if (ii < s) {
			if (IS_BIG_ENDIAN) {
				x->data[x->digits - 1 - ii] = ((uint8_t*) p)[ii];
			} else {
				x->data[ii] = ((uint8_t*) p)[ii];
			}
		} else {
			x->data[ii] = 0;
		}
	}
}

/* comparators */

obliv bool obig_eq(obig x, obig y) obliv;
obliv bool obig_eq_signed(obig x, obig y) obliv;
obliv bool obig_gt(obig x, obig y) obliv;
obliv bool obig_gt_signed(obig x, obig y) obliv;
obliv bool obig_lt(obig x, obig y) obliv;
obliv bool obig_lt_signed(obig x, obig y) obliv;
obliv bool obig_gte(obig x, obig y) obliv;
obliv bool obig_gte_signed(obig x, obig y) obliv;
obliv bool obig_lte(obig x, obig y) obliv;
obliv bool obig_lte_signed(obig x, obig y) obliv;

obliv bool obig_gtz(obig x) obliv {
	obliv bool result = 0;
	for (size_t ii = 0; ii < x.digits; ii++) {
		obliv if (x.data[ii] > 0) {
			result = 1;
		}
	}
	return result;
}

obliv bool obig_gtz_signed(obig x) obliv {
	return (~(obig_ltz_signed(x) | obig_eqz(x))) & 1;
}

obliv bool obig_ltz_signed(obig x) obliv {
	return obyte_msb_is_one(x.data[x.digits - 1]);
}

obliv bool obig_eqz(obig x) obliv {
	obliv bool result = 1;
	for (size_t ii = 0; ii < x.digits; ii++) {
		obliv if (x.data[ii] != 0) {
			result = 0;
		}
	}
	return result;
}

obliv int8_t obig_cmp(obig x, obig y) obliv;
obliv int8_t obig_cmp_signed(obig x, obig y) obliv;

/* nondestructive elementary math */

void obig_shl_native(obig* out, obig x, size_t y) obliv {
	size_t y_digits = y >> 3;
	uint8_t y_bits = y & 0x7;

	for (size_t ii = x.digits + y_digits; ii < out->digits; ii ++) {
		out->data[ii] = 0;
	}

	if (out->digits > y_digits) {
		size_t ii = min(out->digits - y_digits, x.digits);
		if (ii+y_digits < out->digits) out->data[ii+y_digits] = (x.data[ii-1] >> (8-y_bits));
		do {
			ii--;
			out->data[ii+y_digits] = x.data[ii] << y_bits;	
			if (ii > 0) {
				out->data[ii+y_digits] |= (x.data[ii-1] >> (8-y_bits));
			}
		} while (ii > 0);
	}

	for (size_t ii = 0; ii < min(y_digits, out->digits); ii++) {
		out->data[ii] = 0;
	}
}

//TODO: perform as few shifts as necessary for a given output length
void obig_shl_onative(obig* out, obig x, obliv size_t y) obliv {
	obig_copy(out, x);
	for (size_t ii = 0; ii < sizeof(y)/sizeof(obliv bool); ii++) {
		obliv if (y & 1 > 0) {
			obig_shl_native(out, *out, 1 << ii);
		}
		y >>= 1;
	}
}

void obig_shr_native(obig* out, obig x, size_t y) obliv {
	size_t y_digits = y >> 3;
	uint8_t y_bits = y & 0x7;

	for (size_t ii = 0; (ii < out->digits) && (ii+y_digits < x.digits); ii++) {
		out->data[ii] = x.data[ii+y_digits] >> y_bits;
		if (ii+y_digits+1 < x.digits) {
			out->data[ii] = out->data[ii] | (x.data[ii+y_digits+1] << (8-y_bits));
		}
	}

	if (y_digits <= x.digits) {
		for (size_t ii = x.digits-y_digits; ii < out->digits; ii++) {
			out->data[ii] = 0;
		}
	}
}

//TODO: perform as few shifts as necessary for a given output length
void obig_shr_onative(obig* out, obig x, obliv size_t y) obliv {
	obig temp;
	obig* tempref = &temp; //workaround for obliv-c bug
	~obliv(en) {
		obig_init(&temp, x.digits);
	}
	obig_copy(&temp, x);
	for (size_t ii = 0; ii < sizeof(y)/sizeof(obliv bool); ii++) {
		obliv if (y & 1 > 0) {
			obig_shr_native(tempref, temp, 1 << ii);
		}
		y >>= 1;
	}
	obig_copy(out, temp);
	~obliv(en) {
		obig_free(&temp);
	}
}

void obig_neg(obig* out, obig x) obliv {
	obliv uint8_t rem = 1;
	for (size_t ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits) {
			obliv uint16_t temp = (x.data[ii] ^ 0xFF) + rem;
			out->data[ii] = temp;
			rem = temp >> 8;
		} else {
			obliv uint16_t temp = 0xFF + rem;
			out->data[ii] = temp;
			rem = temp >> 8;
		}
	}
}

void obig_add(obig* out, obig x, obig y) obliv {
	obliv uint8_t rem = 0;
	for (size_t ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits && ii < y.digits) {
			obliv uint16_t eresult = x.data[ii] + y.data[ii] + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		} else if (ii < x.digits) {
			obliv uint16_t eresult = x.data[ii] + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		} else if (ii < y.digits) {
			obliv uint16_t eresult = y.data[ii] + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		} else if ((ii >= x.digits && ii == y.digits) || (ii >= y.digits && ii == x.digits)) {
			out->data[ii] = rem;
		} else {
			out->data[ii] = 0;
		}
	}
}

void obig_sub(obig* out, obig x, obig y) obliv {
	obliv uint8_t rem = 1;
	for (size_t ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits && ii < y.digits) {
			obliv uint16_t eresult = x.data[ii] + (y.data[ii] ^ 0xFF) + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		} else if (ii < x.digits) {
			obliv uint16_t eresult = x.data[ii] + 0xFF + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		} else if (ii < y.digits) {
			obliv uint16_t eresult = (y.data[ii] ^ 0xFF) + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		} else {
			obliv uint16_t eresult = 0xFF + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		}
	}
}




obliv uint8_t karatsuba_add(obliv uint8_t *x,obliv uint8_t *y,obliv uint8_t *z,size_t n) obliv {
	obliv uint8_t rem = 0;
	for (size_t ii = 0; ii < n; ii ++) {
		obliv uint16_t eresult = x[ii] + y[ii] + rem;
		z[ii] = eresult;
		rem = eresult >> 8;
	}
	return rem;
}

obliv uint8_t karatsuba_aadd(obliv uint8_t *x,obliv uint8_t *z,size_t n) obliv {
	obliv uint8_t rem = 0;
	for (size_t ii = 0; ii < n; ii ++) {
		obliv uint16_t eresult = z[ii] + x[ii] + rem;
		z[ii] = eresult;
		rem = eresult >> 8;
	}
	return rem;
}

obliv uint8_t karatsuba_asub(obliv uint8_t *y,obliv uint8_t *z,size_t n) obliv {
	obliv uint8_t rem = 0;
	for (size_t ii = 0; ii < n; ii ++) {
		obliv uint16_t eresult = z[ii] - y[ii] - rem;
		z[ii] = eresult;
		rem = (eresult >> 8) & 1;
	}
	return rem;
}

void karatsuba_comba(size_t n,obliv uint8_t *x,obliv uint8_t *y,obliv uint8_t *z) obliv {
	obliv uint32_t temp = 0;
	for (size_t ii = 0; ii < n*2; ii++) {
		size_t bo = min(ii, n-1);
		size_t ao = ii - bo;

		for (size_t jj = 0; jj < min(n-ao, bo+1); jj++) {
			temp = temp + x[ao+jj] * y[bo-jj];
		}
		z[ii] = temp;
		temp >>= 8;
	}
}

#define COMBA_THRESHOLD 1
void karatsuba(size_t n,obliv uint8_t *t,obliv uint8_t *x,obliv uint8_t *y,obliv uint8_t *z) obliv {
	/* This function is an implimentation of the Karatsuba-Comba multiplication method,
	adapted from the MIRACL multiprecision library */

	if ((n % 2 != 0) | (n <= COMBA_THRESHOLD)) {
		karatsuba_comba(n,x,y,z);
		return;
	}

	size_t nd2 = n/2;

	obliv uint8_t c1=karatsuba_add(x,&x[nd2],z,nd2);
	obliv uint8_t c2=karatsuba_add(y,&y[nd2],&z[nd2],nd2);

	obliv uint8_t c=0;
	karatsuba(nd2,&t[n],z,&z[nd2],t);
	obliv if (c1 > 0) c+=karatsuba_aadd(&z[nd2],&t[nd2],nd2);
	obliv if (c2 > 0) c+=karatsuba_aadd(z,&t[nd2],nd2);
	obliv if ((c1 & c2) > 0) c++;

	karatsuba(nd2,&t[n],x,y,z);
	c-=karatsuba_asub(z,t,n);           /* subtract a0*b0 */

	karatsuba(nd2,&t[n],&x[nd2],&y[nd2],&z[n]);
	c-=karatsuba_asub(&z[n],t,n);       /* subtract a1*b1 */

	c+=karatsuba_aadd(t,&z[nd2],n);    /* combine results */

	size_t ii=n+nd2;
	z[ii]+=c;
	obliv bool keepcarrying = true;
	for (ii++;ii<n*2;ii++) { /* propagate carries */
		obliv if (z[n+nd2]<c & keepcarrying & ((ii == n+nd2 + 1) | (z[ii-1]==0))) {
			z[ii]++;
		} else {
			keepcarrying = false;
		}
	}
}

void obig_mul(obig* out, obig x, obig y) obliv {

	~obliv(en) {
		size_t indigits = max(x.digits, y.digits);
		obliv uint8_t * temp = calloc(indigits * 2, sizeof(obliv uint8_t));

		obliv uint8_t * x2;
		obliv uint8_t * y2;
		obliv uint8_t * z;

		if (x.digits < indigits) {
			x2 = calloc(indigits, sizeof(obliv uint8_t));
			size_t ii = 0;
			for (; ii < x.digits; ii++) {
				x2[ii] = x.data[ii];
			}
		} else {
			x2 = x.data;
		}

		if (y.digits < indigits) {
			y2 = calloc(indigits, sizeof(obliv uint8_t));
			size_t ii = 0;
			for (; ii < y.digits; ii++) {
				y2[ii] = y.data[ii];
			}
		} else {
			y2 = y.data;
		}

		if (out->digits < indigits * 2) {
			z = calloc(indigits * 2, sizeof(obliv uint8_t));
		} else {
			z = out->data;
		}

		obliv if (en) karatsuba(indigits,temp, x2, y2, z);

		if (x.digits < indigits) {
			free(x2);
		}
		if (y.digits < indigits) {
			free(y2);
		}
		if (out->digits < indigits * 2) {
			for (size_t ii = 0; ii < out->digits; ii++) {
				out->data[ii] = z[ii];
			}
			free(z);
		} else {
			for (size_t ii = indigits * 2; ii < out->digits; ii++) {
				out->data[ii] = 0;
			}
		}

		free(temp);
	}
}



obliv size_t knuth_d_count_leading_zeros(obliv uint8_t * x, size_t n) obliv {
	obliv size_t result = 0;
	obliv bool found_one = false;
	for (size_t ii = 0; ii < n; ii++) {
		obliv uint8_t temp = x[ii];
		for (size_t jj = 0; jj < 8; jj++) {
			obliv if (((temp >> jj) & 1) > 0) {
				result = 0;
			} else {
				result ++;
			}
		}
	}
	return result;
}

void knuth_d(obliv uint8_t *u, obliv uint8_t *v, obliv uint8_t *q, size_t n, size_t m) obliv {
	/* this is a straightforward implementation of Knuth's Algorithm D,
	as described in The Art of Computer Programming Vol 2, Section 4.3.1

	In addition, the implementation is partially based upon code from Hacker's Delight,
	available at http://www.hackersdelight.org/hdcodetxt/divmnu64.c.txt
	
	we assume that u and v have been normalized (i.e. the first digit of v is 1),
	that n >= 2, and that our inputs and outputs are of the following lengths:
	u (dividend): m+n
	v (divisor): n
	q (quotient): m+1
	r (remainder): n
	*/

	for (int64_t jj = m; jj >= 0; jj--) {
		//Knuth D3
		obliv uint8_t qhat;
		obliv uint16_t temp1, temp2;
		obliv if (u[jj+n] == v[n-1]) {
			qhat = ~0;
		} else {
			qhat = (((obliv uint16_t)u[jj+n] << 8) + u[jj+n-1]) / v[n-1];
		}

		temp1 = v[n-2] * qhat;
		temp2 = ((((obliv uint16_t)u[jj+n] << 8) + u[jj+n-1] - qhat * v[n-1]) << 8) +u[jj+n-2];
		obliv if (temp1 > temp2) {
			qhat--;
			temp1 -= v[n-2];
			temp2 = ((((obliv uint16_t)u[jj+n] << 8) + u[jj+n-1] - qhat * v[n-1]) << 8) +u[jj+n-2];
		}
		obliv if (temp1 > temp2) qhat--;

		//Knuth D4
		obliv int16_t carry = 0;
		obliv int16_t product;
		for (size_t ii = 0; ii < n; ii++) {
			temp1 = qhat*v[ii];
			product = u[ii+jj] - carry - (temp1 & 0xFF);
			u[ii+jj] = product;
			carry = (temp1 >> 8) - (product >> 8);
		}
		product = u[n+jj] - carry;
		u[n+jj] = product;


		//Knuth D5
		q[jj] = qhat;
		carry = 0;
		obliv if (product < 0) {
			// Knuth D6
			q[jj]--;
			for (size_t ii = 0; ii < n; ii++) {
				temp1 = (obliv uint16_t) u[ii+jj] + v[ii] + carry;
				u[ii+jj] = temp1;
				carry = temp1 >> 8;
			}
			u[jj+n] = u[jj+n] + carry;
		}
	}
}

void knuth_d_1(obliv uint8_t *u, obliv uint8_t *v, obliv uint8_t *q, obliv uint8_t * r, size_t m) obliv {
	obliv int16_t carry = 0;                            
	for (int64_t jj = m - 1; jj >= 0; jj--) {    
		q[jj] = ((carry << 8) + u[jj])/v[0];      
		carry = ((carry << 8) + u[jj]) - q[jj]*v[0];
	}
	r[0] = carry;
}

obliv bool obig_div_mod(obig* q, obig* r, obig x, obig y) obliv {

	obig u;
	obig * uref = &u; //workaround for obliv-c quirk
	obig v;
	obig * vref = &v; //workaround for obliv-c quirk
	obliv uint8_t * q2;
	obliv uint8_t * r2;
	obliv bool success;

	size_t m = x.digits;
	size_t n = y.digits;

	~obliv(en) {

		if (n > 1) {
			obig_init(uref, m + n + 1);
			obig_init(vref, n);
		}

		if (q != NULL && q->digits > m) {
			q2 = q->data;
		} else {
			q2 = calloc(m + 1, sizeof(obliv uint8_t));
		}
	}

	if (n > 1) {
		// Normalize inputs (Knuth D1)
		obliv size_t normalize_amount = knuth_d_count_leading_zeros(y.data, n);
		success = normalize_amount < (n * 8);

		obig_shl_onative(uref, x, normalize_amount);
		obig_shl_onative(vref, y, normalize_amount);

		knuth_d(u.data, v.data, q2, n, m);

		// Unnormalize output (Knuth D7)
		if (r != NULL) obig_shr_onative(r, u, normalize_amount);
	} else {
		obliv uint8_t rtemp;
		if (r != NULL) r2 = r->data;
		else r2 = &rtemp;

		success = y.data[0] > 0;
		knuth_d_1(x.data, y.data, q2, r2, m);

		if (r != NULL) {
			for (size_t ii = 1; ii < r->digits; ii++) {
				r->data[ii] = 0;
			}
		}
	}

	~obliv (en) {
		if (q != NULL) {
			if (q2 == q->data) {
				for (size_t ii = m + 2; ii < q->digits; ii++) {
					q->data[ii] = 0;
				}
			} else {
				for (size_t ii = 0; ii < q->digits; ii++) {
					q->data[ii] = q2[ii];
				}
				free(q2);
			}
		} else {
			free(q2);
		}
		
		if (n > 1) {
			obig_free(&u);
			obig_free(&v);
		}
	}	

	return success;
}



void obig_not(obig* out, obig x) obliv {
	for (size_t ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits) {
			out->data[ii] = ~x.data[ii];
		} else {
			out->data[ii] = 0xFF;
		}
	}
}

void obig_and(obig* out, obig x, obig y) obliv {
	for (size_t ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits && ii < y.digits) {
			out->data[ii] = x.data[ii] & y.data[ii];
		} else {
			out->data[ii] = 0;
		}
	}
}

void obig_or(obig* out, obig x, obig y) obliv {
	for (size_t ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits && ii < y.digits) {
			out->data[ii] = x.data[ii] | y.data[ii];
		} else if (ii < x.digits) {
			out->data[ii] = x.data[ii];
		} else if (ii < y.digits) {
			out->data[ii] = y.data[ii];
		} else {
			out->data[ii] = 0;
		}
	}
}

void obig_xor(obig* out, obig x, obig y) obliv {
	for (size_t ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits && ii < y.digits) {
			out->data[ii] = x.data[ii] ^ y.data[ii];
		} else if (ii < x.digits) {
			out->data[ii] = x.data[ii];
		} else if (ii < y.digits) {
			out->data[ii] = y.data[ii];
		} else {
			out->data[ii] = 0;
		}
	}
}	