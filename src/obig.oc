#include "obig.oh"

/* Utility functions to be used only internally */

unsigned int ceildiv(unsigned int dividend, unsigned int divisor) {
	return (dividend + divisor - 1) / divisor; // ceil(dividend/divisor)
}

int max(int a, int b) {
	return (a > b ? a : b);
}

int min(int a, int b) {
	return (a < b ? a : b);
}

obyte obyte_msb_is_one(obyte x) {
	obyte result;
	//big_digit pattern = ~((big_digit)-1 >> 1);
	obliv if (x & 0x80 == 0) {
		result = 0;
	} else {
		result = 1;
	}
	return result;
}

obyte obyte_msb_is_one_obliv(obyte x) obliv {
	obyte result;
	obliv if (x & 0x80 == 0) {
		result = 0;
	} else {
		result = 1;
	}
	return result;
}


/* memory management */

void obig_init(obig* x, unsigned int bytes) {
	x->digits = bytes; //ceildiv(bytes,sizeof(big_digit));
	x->data = malloc(sizeof(obyte) * x->digits);
}

void obig_free(obig* x) {
	free(x->data);
	x->digits = 0;
	x->data = NULL;
}

void obig_resize(obig* x, unsigned int bytes) {
	obig temp;
	temp.digits = bytes; //ceildiv(bytes, sizeof(big_digit));
	temp.data = malloc(sizeof(obyte) * temp.digits);

	obig_copy(&temp, *x);

	free(x->data);
	x->digits = temp.digits;
	x->data = temp.data;
}

void obig_resize_signed(obig* x, int bytes);
void obig_match_sizes(obig* x, obig* y);
void obig_match_sizes_signed(obig* x, obig* y);

void obig_copy(obig* out, obig in) {
	for (int ii = 0; ii < out->digits; ii++) {
		if (ii < in.digits) {
			out->data[ii] = in.data[ii];
		} else {
			out->data[ii] = 0;
		}
	}
}

void obig_copy_obliv(obig* out, obig in) obliv {
	for (int ii = 0; ii < out->digits; ii++) {
		if (ii < in.digits) {
			out->data[ii] = in.data[ii];
		} else {
			out->data[ii] = 0;
		}
	}
}

void obig_copy_signed(obig* out, obig in) {
	if (out->digits > in.digits) {
		obyte inputIsNegative = odigit_msb_is_one(in.data[in.digits-1]);
		for (int ii = 0; ii < out->digits; ii++) {
			if (ii < in.digits) {
				out->data[ii] = in.data[ii];
			} else {
				// sign extend with MSB of input
				obliv if(inputIsNegative > 0) {
					out->data[ii] = -1;	
				} else {
					out->data[ii] = 0;
				}
			}
		}
	} else {
		for (int ii = 0; ii < out->digits; ii++) {
			out->data[ii] = in.data[ii];
		}
	}
}

void obig_copy_signed_obliv(obig* out, obig in) obliv {
	if (out->digits > in.digits) {
		obyte inputIsNegative = odigit_msb_is_one_obliv(in.data[in.digits-1]);
		for (int ii = 0; ii < out->digits; ii++) {
			if (ii < in.digits) {
				out->data[ii] = in.data[ii];
			} else {
				// sign extend with MSB of input
				obliv if(inputIsNegative > 0) {
					out->data[ii] = -1;	
				} else {
					out->data[ii] = 0;
				}
			}
		}
	} else {
		for (int ii = 0; ii < out->digits; ii++) {
			out->data[ii] = in.data[ii];
		}
	}
}

/* convenience setters */

void obig_zero(obig* x) {
	for (int ii = 0; ii < x->digits; ii++) {
		x->data[ii] = 0;
	}
}

void obig_zero_obliv(obig* x) obliv {
	for (int ii = 0; ii < x->digits; ii++) {
		x->data[ii] = 0;
	}
}

void obig_one(obig* x) {
	x->data[0] = 1;
	for (int ii = 1; ii < x->digits; ii++) {
		x->data[ii] = 0;
	}
}

void obig_one_obliv(obig* x) obliv {
	x->data[0] = 1;
	for (int ii = 1; ii < x->digits; ii++) {
		x->data[ii] = 0;
	}
}

void obig_set_native(obig* x, long long y);
void obig_set_onative(obig* x, obliv long long y);
void obig_set_native_obliv(obig* x, long long y) obliv;
void obig_set_onative_obliv(obig* x, obliv long long y) obliv;

/* comparators */

obyte obig_eq_obliv(obig x, obig y) obliv;
obyte obig_eq_signed_obliv(obig x, obig y) obliv;
obyte obig_gt_obliv(obig x, obig y) obliv;
obyte obig_gt_signed_obliv(obig x, obig y) obliv;
obyte obig_lt_obliv(obig x, obig y) obliv;
obyte obig_lt_signed_obliv(obig x, obig y) obliv;
obyte obig_gte_obliv(obig x, obig y) obliv;
obyte obig_gte_signed_obliv(obig x, obig y) obliv;
obyte obig_lte_obliv(obig x, obig y) obliv;
obyte obig_lte_signed_obliv(obig x, obig y) obliv;

obyte obig_gtz_obliv(obig x) obliv {
	obyte result = 0;
	for (int ii = 0; ii < x.digits; ii++) {
		obliv if (x.data[ii] > 0) {
			result = 1;
		}
	}
	return result;
}

obyte obig_gtz_signed_obliv(obig x) obliv {
	return (~(obig_ltz_signed_obliv(x) | obig_eqz_obliv(x))) & 1;
}

obyte obig_ltz_signed_obliv(obig x) obliv {
	return odigit_msb_is_one_obliv(x.data[x.digits - 1]);
}

obyte obig_eqz_obliv(obig x) obliv {
	obyte result = 1;
	for (int ii = 0; ii < x.digits; ii++) {
		obliv if (x.data[ii] != 0) {
			result = 0;
		}
	}
	return result;
}

obyte obig_cmp_obliv(obig x, obig y) obliv;
obyte obig_cmp_signed_obliv(obig x, obig y) obliv;

/* augmented assignment */

void obig_aa_shl1(obig* x);
void obig_aa_shl_native(obig* x, unsigned int y);
void obig_aa_shl_onative(obig* x, obliv unsigned int y);
void obig_aa_shr1(obig* x);
void obig_aa_shr_native(obig* x, unsigned int y);
void obig_aa_shr_onative(obig* x, obliv unsigned int y);

void obig_aa_neg_signed(obig* x) {
	obyte rem = 1;
	for (int ii = 0; ii < x->digits; ii ++) {
		obliv unsigned short = (x->data[ii] ^ 0xFF) + rem;
		x->data[ii] = temp;
		rem = temp >> 8;
	}
}

void obig_aa_add(obig* x, obig y);
void obig_aa_add_native(obig* x, long long y);
void obig_aa_add_onative(obig* x, obliv long long y);
void obig_aa_sub(obig* x, obig y);
void obig_aa_sub_native(obig* x, long long y);
void obig_aa_sub_onative(obig* x, obliv long long y);

void obig_aa_not(obig* x) {
	for (int ii = 0; ii < x->digits; ii ++) {
		x->data[ii] = ~x->data[ii];
	}
}

void obig_aa_and(obig* x, obig y) {
	for (int ii = 0; ii < x->digits; ii ++) {
		if (ii < y.digits) {
			x->data[ii] = x->data[ii] & y.data[ii];
		} else {
			x->data[ii] = 0;
		}
	}
}

void obig_aa_or(obig* x, obig y) {
	for (int ii = 0; ii < x->digits; ii ++) {
		if (ii < y.digits) {
			x->data[ii] = x->data[ii] | y.data[ii];
		} else {
			x->data[ii] = x->data[ii];
		}
	}
}

void obig_aa_xor(obig* x, obig y) {
	for (int ii = 0; ii < x->digits; ii ++) {
		if (ii < y.digits) {
			x->data[ii] = x->data[ii] ^ y.data[ii];
		} else {
			x->data[ii] = x->data[ii];
		}
	}
}

void obig_aa_shl1_obliv(obig* x) obliv;
void obig_aa_shl_native_obliv(obig* x, unsigned int y) obliv;
void obig_aa_shl_onative_obliv(obig* x, obliv unsigned int y) obliv;
void obig_aa_shr1_obliv(obig* x) obliv;
void obig_aa_shr_native_obliv(obig* x, unsigned int y) obliv;
void obig_aa_shr_onative_obliv(obig* x, obliv unsigned int y) obliv;

void obig_aa_neg_signed_obliv(obig* x) obliv {
	obyte rem = 1;
	for (int ii = 0; ii < x->digits; ii ++) {
		obliv unsigned short = (x->data[ii] ^ 0xFF) + rem;
		x->data[ii] = temp;
		rem = temp >> 8;
	}
}

void obig_aa_add_obliv(obig* x, obig y) obliv;
void obig_aa_add_native_obliv(obig* x, long long y) obliv;
void obig_aa_add_onative_obliv(obig* x, obliv long long y) obliv;
void obig_aa_sub_obliv(obig* x, obig y) obliv;
void obig_aa_sub_native_obliv(obig* x, long long y) obliv;
void obig_aa_sub_onative_obliv(obig* x, obliv long long y) obliv;

void obig_aa_not_obliv(obig* x) obliv {
	for (int ii = 0; ii < x->digits; ii ++) {
		x->data[ii] = ~x->data[ii];
	}
}

void obig_aa_and_obliv(obig* x, obig y) obliv {
	for (int ii = 0; ii < x->digits; ii ++) {
		if (ii < y.digits) {
			x->data[ii] = x->data[ii] & y.data[ii];
		} else {
			x->data[ii] = 0;
		}
	}
}

void obig_aa_or_obliv(obig* x, obig y) obliv {
	for (int ii = 0; ii < x->digits; ii ++) {
		if (ii < y.digits) {
			x->data[ii] = x->data[ii] | y.data[ii];
		} else {
			x->data[ii] = x->data[ii];
		}
	}
}

void obig_aa_xor_obliv(obig* x, obig y) obliv {
	for (int ii = 0; ii < x->digits; ii ++) {
		if (ii < y.digits) {
			x->data[ii] = x->data[ii] ^ y.data[ii];
		} else {
			x->data[ii] = x->data[ii];
		}
	}
}

/* nondestructive elementary math */

void obig_shl1(obig* out, obig x);
void obig_shl_native(obig* out, obig x, unsigned int y);
void obig_shl_onative(obig* out, obig x, obliv unsigned int y);
void obig_shr1(obig* out, obig x);
void obig_shr_native(obig* out, obig x, unsigned int y);
void obig_shr_onative(obig* out, obig x, obliv unsigned int y);

void obig_neg_signed(obig* out, obig x) {
	obyte rem = 1;
	for (int ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits) {
			obliv unsigned short temp = (x.data[ii] ^ 0xFF) + rem;
			out->data[ii] = temp;
			rem = temp >> 8;
		} else {
			obliv if (obyte_msb_is_one_obliv(x.data[x.digits - 1]) == 0) {
				obliv unsigned short temp = 0xFF + rem;
				x->data[ii] = temp;
				rem = temp >> 8;
			} else {
				obliv unsigned short temp = 0x00 + rem;
				x->data[ii] = temp;
				rem = temp >> 8;
			}
		}
	}
}

void obig_add(obig* out, obig x, obig y);
void obig_add_native(obig* out, obig x, long long y);
void obig_add_onative(obig* out, obig x, obliv long long y);
void obig_sub(obig* out, obig x, obig y);
void obig_sub_native(obig* out, obig x, long long y);
void obig_sub_onative(obig* out, obig x, obliv long long y);

void obig_not(obig* out, obig x) {
	for (int ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits) {
			out->data[ii] = ~x.data[ii];
		} else {
			out->data[ii] = 0;
		}
	}
}

void obig_and(obig* out, obig x, obig y);
void obig_or(obig* out, obig x, obig y);
void obig_xor(obig* out, obig x, obig y);

void obig_shl1_obliv(obig* out, obig x) obliv;
void obig_shl_native_obliv(obig* out, obig x, unsigned int y) obliv;
void obig_shl_onative_obliv(obig* out, obig x, obliv unsigned int y) obliv;
void obig_shr1_obliv(obig* out, obig x) obliv;
void obig_shr_native_obliv(obig* out, obig x, unsigned int y) obliv;
void obig_shr_onative_obliv(obig* out, obig x, obliv unsigned int y) obliv;

void obig_neg_signed_obliv(obig* out, obig x) obliv {
	obyte rem = 1;
	for (int ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits) {
			obliv unsigned short temp = (x.data[ii] ^ 0xFF) + rem;
			out->data[ii] = temp;
			rem = temp >> 8;
		} else {
			obliv if (obyte_msb_is_one_obliv(x.data[x.digits - 1]) == 0) {
				obliv unsigned short temp = 0xFF + rem;
				x->data[ii] = temp;
				rem = temp >> 8;
			} else {
				obliv unsigned short temp = 0x00 + rem;
				x->data[ii] = temp;
				rem = temp >> 8;
			}
		}
	}
}

void obig_add_obliv(obig* out, obig x, obig y) obliv;
void obig_add_native_obliv(obig* out, obig x, long long y) obliv;
void obig_add_onative_obliv(obig* out, obig x, obliv long long y) obliv;
void obig_sub_obliv(obig* out, obig x, obig y) obliv;
void obig_sub_native_obliv(obig* out, obig x, long long y) obliv;
void obig_sub_onative_obliv(obig* out, obig x, obliv long long y) obliv;

void obig_not_obliv(obig* out, obig x) obliv {
	for (int ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits) {
			out->data[ii] = ~x.data[ii];
		} else {
			out->data[ii] = 0;
		}
	}
}

void obig_and_obliv(obig* out, obig x, obig y) obliv;
void obig_or_obliv(obig* out, obig x, obig y) obliv;
void obig_xor_obliv(obig* out, obig x, obig y) obliv;	