#include <stdint.h>
#include <stdio.h>

#include "obig.oh"

#define IS_BIG_ENDIAN (*(uint16_t *)"\0\xff" < 0x100)

/* Utility functions to be used only internally */

unsigned int ceildiv(unsigned int dividend, unsigned int divisor) {
	return (dividend + divisor - 1) / divisor; // ceil(dividend/divisor)
}

int max(int a, int b) {
	return (a > b ? a : b);
}

int min(int a, int b) {
	return (a < b ? a : b);
}

obyte obyte_msb_is_one(obyte x) {
	obyte result;
	//big_digit pattern = ~((big_digit)-1 >> 1);
	obliv if (x & 0x80 == 0) {
		result = 0;
	} else {
		result = 1;
	}
	return result;
}

obyte obyte_msb_is_one_obliv(obyte x) obliv {
	obyte result;
	obliv if (x & 0x80 == 0) {
		result = 0;
	} else {
		result = 1;
	}
	return result;
}


/* memory management */

void obig_init(obig* x, unsigned int bytes) {
	x->digits = bytes; //ceildiv(bytes,sizeof(big_digit));
	x->data = malloc(sizeof(obyte) * x->digits);
}

void obig_free(obig* x) {
	free(x->data);
	x->digits = 0;
	x->data = NULL;
}

void obig_resize(obig* x, unsigned int bytes) {
	obig temp;
	temp.digits = bytes; //ceildiv(bytes, sizeof(big_digit));
	temp.data = malloc(sizeof(obyte) * temp.digits);

	obig_copy(&temp, *x);

	free(x->data);
	x->digits = temp.digits;
	x->data = temp.data;
}

void obig_resize_signed(obig* x, int bytes);
void obig_match_sizes(obig* x, obig* y);
void obig_match_sizes_signed(obig* x, obig* y);

void obig_copy(obig* out, obig in) {
	for (int ii = 0; ii < out->digits; ii++) {
		if (ii < in.digits) {
			out->data[ii] = in.data[ii];
		} else {
			out->data[ii] = 0;
		}
	}
}

void obig_copy_obliv(obig* out, obig in) obliv {
	for (int ii = 0; ii < out->digits; ii++) {
		if (ii < in.digits) {
			out->data[ii] = in.data[ii];
		} else {
			out->data[ii] = 0;
		}
	}
}

void obig_copy_signed(obig* out, obig in) {
	if (out->digits > in.digits) {
		obyte inputIsNegative = obyte_msb_is_one(in.data[in.digits-1]);
		for (int ii = 0; ii < out->digits; ii++) {
			if (ii < in.digits) {
				out->data[ii] = in.data[ii];
			} else {
				// sign extend with MSB of input
				obliv if(inputIsNegative > 0) {
					out->data[ii] = -1;	
				} else {
					out->data[ii] = 0;
				}
			}
		}
	} else {
		for (int ii = 0; ii < out->digits; ii++) {
			out->data[ii] = in.data[ii];
		}
	}
}

void obig_copy_signed_obliv(obig* out, obig in) obliv {
	if (out->digits > in.digits) {
		obyte inputIsNegative = obyte_msb_is_one_obliv(in.data[in.digits-1]);
		for (int ii = 0; ii < out->digits; ii++) {
			if (ii < in.digits) {
				out->data[ii] = in.data[ii];
			} else {
				// sign extend with MSB of input
				obliv if(inputIsNegative > 0) {
					out->data[ii] = -1;	
				} else {
					out->data[ii] = 0;
				}
			}
		}
	} else {
		for (int ii = 0; ii < out->digits; ii++) {
			out->data[ii] = in.data[ii];
		}
	}
}

/* convenience setters */

void obig_zero(obig* x) {
	for (int ii = 0; ii < x->digits; ii++) {
		x->data[ii] = 0;
	}
}

void obig_zero_obliv(obig* x) obliv {
	for (int ii = 0; ii < x->digits; ii++) {
		x->data[ii] = 0;
	}
}

void obig_one(obig* x) {
	x->data[0] = 1;
	for (int ii = 1; ii < x->digits; ii++) {
		x->data[ii] = 0;
	}
}

void obig_one_obliv(obig* x) obliv {
	x->data[0] = 1;
	for (int ii = 1; ii < x->digits; ii++) {
		x->data[ii] = 0;
	}
}

void obig_set_native(obig* x, long long y) {
	obig_set_pointed(x, &y, sizeof(y));
}

/*void obig_set_onative(obig* x, obliv long long y) {
	obig_set_opointed(x, &y, sizeof(long long));
}*/

void obig_set_pointed(obig* x, void* p, size_t s) {
	for (unsigned int ii = 0; ii < x->digits; ii++) {
		if (ii < s) {
			if (IS_BIG_ENDIAN) {
				x->data[x->digits - 1 - ii] = ((unsigned char*) p)[ii];
			} else {
				x->data[ii] = ((unsigned char*) p)[ii];
			}
		} else {
			x->data[ii] = 0;
		}
	}
}

/*void obig_set_opointed(obig* x, obliv void* p, size_t s) {
	for (unsigned int ii = 0; ii < x->digits; ii++) {
		if (x < s) {
			x->data[ii] = *p >> (ii * 8);
		} else {
			x->data[ii] = 0;
		}
	}
}*/

void obig_set_native_obliv(obig* x, long long y) obliv {
	obig_set_pointed_obliv(x, &y, sizeof(y));
}

/*void obig_set_onative_obliv(obig* x, obliv long long y) obliv {
	obig_set_opointed(x, &y, sizeof(long long));
}*/

void obig_set_pointed_obliv(obig* x, void* p, size_t s) obliv {
	for (unsigned int ii = 0; ii < x->digits; ii++) {
		if (ii < s) {
			if (IS_BIG_ENDIAN) {
				x->data[x->digits - 1 - ii] = ((unsigned char*) p)[ii];
			} else {
				x->data[ii] = ((unsigned char*) p)[ii];
			}
		} else {
			x->data[ii] = 0;
		}
	}
}

/*void obig_set_opointed_obliv(obig* x, obliv void* p, size_t s) obliv {
	for (unsigned int ii = 0; ii < x->digits; ii++) {
		if (x < s) {
			x->data[ii] = *p >> (ii * 8);
		} else {
			x->data[ii] = 0;
		}
	}
}*/

/* comparators */

obyte obig_eq_obliv(obig x, obig y) obliv;
obyte obig_eq_signed_obliv(obig x, obig y) obliv;
obyte obig_gt_obliv(obig x, obig y) obliv;
obyte obig_gt_signed_obliv(obig x, obig y) obliv;
obyte obig_lt_obliv(obig x, obig y) obliv;
obyte obig_lt_signed_obliv(obig x, obig y) obliv;
obyte obig_gte_obliv(obig x, obig y) obliv;
obyte obig_gte_signed_obliv(obig x, obig y) obliv;
obyte obig_lte_obliv(obig x, obig y) obliv;
obyte obig_lte_signed_obliv(obig x, obig y) obliv;

obyte obig_gtz_obliv(obig x) obliv {
	obyte result = 0;
	for (int ii = 0; ii < x.digits; ii++) {
		obliv if (x.data[ii] > 0) {
			result = 1;
		}
	}
	return result;
}

obyte obig_gtz_signed_obliv(obig x) obliv {
	return (~(obig_ltz_signed_obliv(x) | obig_eqz_obliv(x))) & 1;
}

obyte obig_ltz_signed_obliv(obig x) obliv {
	return obyte_msb_is_one_obliv(x.data[x.digits - 1]);
}

obyte obig_eqz_obliv(obig x) obliv {
	obyte result = 1;
	for (int ii = 0; ii < x.digits; ii++) {
		obliv if (x.data[ii] != 0) {
			result = 0;
		}
	}
	return result;
}

obyte obig_cmp_obliv(obig x, obig y) obliv;
obyte obig_cmp_signed_obliv(obig x, obig y) obliv;

/* nondestructive elementary math */

void obig_shl1(obig* out, obig x) {
	obyte rem = 0;
	obyte lastRem = 0;
	for (int ii = 0; ii < out->digits; ii++) {
		if (ii < x.digits) {
			rem = x.data[ii] & 0x80;
			obliv if (lastRem > 0) {
				out->data[ii] = (x.data[ii] << 1) | 1;
			} else {
				out->data[ii] = x.data[ii] << 1;
			}
			lastRem = rem;
		} else if (ii == x.digits) {
			obliv if (lastRem > 0) {
				out->data[ii] = 1;
			} else {
				out->data[ii] = 0;
			}
		} else {
			out->data[ii] = 0;
		}
	}
}

void obig_shl_native(obig* out, obig x, unsigned int y) {
	if (y > 0) {
		obig_shl1(out, x);
	} else {
		obig_copy(out, x);
	}
	for (unsigned int ii = 1; ii < y; ii ++) {
		obig_shl1(out, *out);
	}
}

void obig_shl_onative(obig* out, obig x, obliv unsigned int y) {
	obig_copy(out, x);
	for (unsigned int ii = 0; ii < x.digits; ii++) {
		obliv if (ii < y) {
			obig_shl1_obliv(out, *out);
		}
	}
}

void obig_shr1(obig* out, obig x) {
	obyte rem = 0;
	obyte lastRem = 0;
	for (int ii = out->digits - 1; ii >= 0; ii--) {
		if (ii >= x.digits) {
			out->data[ii] = 0;
		} else {
			rem = x.data[ii] & 1;
			obliv if (lastRem > 0) {
				out->data[ii] = (x.data[ii] >> 1) | 0x80;
			} else {
				out->data[ii] = (x.data[ii] >> 1);
			}
			lastRem = rem;
		}
	}
}

void obig_shr_native(obig* out, obig x, unsigned int y) {
	if (y > 0) {
		obig_shr1(out, x);
	} else {
		obig_copy(out, x);
	}
	for (unsigned int ii = 1; ii < y; ii ++) {
		obig_shr1(out, *out);
	}
}

void obig_shr_onative(obig* out, obig x, obliv unsigned int y) {
	obig_copy(out, x);
	for (unsigned int ii = 0; ii < x.digits; ii++) {
		obliv if (ii < y) {
			obig_shr1_obliv(out, *out);
		}
	}
}

void obig_neg(obig* out, obig x) {
	obyte rem = 1;
	for (int ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits) {
			obliv unsigned short temp = (x.data[ii] ^ 0xFF) + rem;
			out->data[ii] = temp;
			rem = temp >> 8;
		} else {
			//obliv if (obyte_msb_is_one_obliv(x.data[x.digits - 1]) == 0) {
				obliv unsigned short temp = 0xFF + rem;
				out->data[ii] = temp;
				rem = temp >> 8;
			//} else {
			//	obliv unsigned short temp = 0x00 + rem;
			//	x.data[ii] = temp;
			//	rem = temp >> 8;
			//}
		}
	}
}

void obig_add(obig* out, obig x, obig y) {
	obyte rem = 0;
	for (int ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits && ii < y.digits) {
			obliv unsigned short eresult = x.data[ii] + y.data[ii] + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		} else if (ii < x.digits) {
			obliv unsigned short eresult = x.data[ii] + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		} else if (ii < y.digits) {
			obliv unsigned short eresult = y.data[ii] + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		} else if ((ii >= x.digits && ii == y.digits) || (ii >= y.digits && ii == x.digits)) {
			out->data[ii] = rem;
		} else {
			out->data[ii] = 0;
		}
	}
}

void obig_sub(obig* out, obig x, obig y) {
	obyte rem = 1;
	for (int ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits && ii < y.digits) {
			obliv unsigned short eresult = x.data[ii] + (y.data[ii] ^ 0xFF) + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		} else if (ii < x.digits) {
			obliv unsigned short eresult = x.data[ii] + 0xFF + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		} else if (ii < y.digits) {
			obliv unsigned short eresult = (y.data[ii] ^ 0xFF) + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		} else {
			obliv unsigned short eresult = 0xFF + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		}
	}
}

void obig_not(obig* out, obig x) {
	for (int ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits) {
			out->data[ii] = ~x.data[ii];
		} else {
			out->data[ii] = 0xFF;
		}
	}
}

void obig_and(obig* out, obig x, obig y) {
	for (int ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits && ii < y.digits) {
			out->data[ii] = x.data[ii] & y.data[ii];
		} else {
			out->data[ii] = 0;
		}
	}
}

void obig_or(obig* out, obig x, obig y) {
	for (int ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits && ii < y.digits) {
			out->data[ii] = x.data[ii] | y.data[ii];
		} else if (ii < x.digits) {
			out->data[ii] = x.data[ii];
		} else if (ii < y.digits) {
			out->data[ii] = y.data[ii];
		} else {
			out->data[ii] = 0;
		}
	}
}

void obig_xor(obig* out, obig x, obig y) {
	for (int ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits && ii < y.digits) {
			out->data[ii] = x.data[ii] ^ y.data[ii];
		} else if (ii < x.digits) {
			out->data[ii] = x.data[ii];
		} else if (ii < y.digits) {
			out->data[ii] = y.data[ii];
		} else {
			out->data[ii] = 0;
		}
	}
}

void obig_shl1_obliv(obig* out, obig x) obliv {
	obyte rem = 0;
	obyte lastRem = 0;
	for (int ii = 0; ii < out->digits; ii++) {
		if (ii < x.digits) {
			rem = x.data[ii] & 0x80;
			obliv if (lastRem > 0) {
				out->data[ii] = (x.data[ii] << 1) | 1;
			} else {
				out->data[ii] = x.data[ii] << 1;
			}
			lastRem = rem;
		} else if (ii == x.digits) {
			obliv if (lastRem > 0) {
				out->data[ii] = 1;
			} else {
				out->data[ii] = 0;
			}
		} else {
			out->data[ii] = 0;
		}
	}
}

void obig_shl_native_obliv(obig* out, obig x, unsigned int y) obliv {
	if (y > 0) {
		obig_shl1_obliv(out, x);
	} else {
		obig_copy_obliv(out, x);
	}
	for (unsigned int ii = 1; ii < y; ii ++) {
		obig_shl1_obliv(out, *out);
	}
}

void obig_shl_onative_obliv(obig* out, obig x, obliv unsigned int y) obliv {
	obig_copy_obliv(out, x);
	for (unsigned int ii = 0; ii < x.digits; ii++) {
		obliv if (ii < y) {
			obig_shl1_obliv(out, *out);
		}
	}
}

void obig_shr1_obliv(obig* out, obig x) obliv {
	obyte rem = 0;
	obyte lastRem = 0;
	for (int ii = out->digits - 1; ii >= 0; ii--) {
		if (ii >= x.digits) {
			out->data[ii] = 0;
		} else {
			rem = x.data[ii] & 1;
			obliv if (lastRem > 0) {
				out->data[ii] = (x.data[ii] >> 1) | 0x80;
			} else {
				out->data[ii] = (x.data[ii] >> 1);
			}
			lastRem = rem;
		}
	}
}

void obig_shr_native_obliv(obig* out, obig x, unsigned int y) obliv {
	if (y > 0) {
		obig_shr1_obliv(out, x);
	} else {
		obig_copy_obliv(out, x);
	}
	for (unsigned int ii = 1; ii < y; ii ++) {
		obig_shr1_obliv(out, *out);
	}
}

void obig_shr_onative_obliv(obig* out, obig x, obliv unsigned int y) obliv {
	obig_copy_obliv(out, x);
	for (unsigned int ii = 0; ii < x.digits; ii++) {
		obliv if (ii < y) {
			obig_shr1_obliv(out, *out);
		}
	}
}

void obig_neg_obliv(obig* out, obig x) obliv {
	obyte rem = 1;
	for (int ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits) {
			obliv unsigned short temp = (x.data[ii] ^ 0xFF) + rem;
			out->data[ii] = temp;
			rem = temp >> 8;
		} else {
			//obliv if (obyte_msb_is_one_obliv(x.data[x.digits - 1]) == 0) {
				obliv unsigned short temp = 0xFF + rem;
				x.data[ii] = temp;
				rem = temp >> 8;
			//} else {
			//	obliv unsigned short temp = 0x00 + rem;
			//	x.data[ii] = temp;
			//	rem = temp >> 8;
			//}
		}
	}
}

void obig_add_obliv(obig* out, obig x, obig y) obliv {
	obyte rem = 0;
	for (int ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits && ii < y.digits) {
			obliv unsigned short eresult = x.data[ii] + y.data[ii] + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		} else if (ii < x.digits) {
			obliv unsigned short eresult = x.data[ii] + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		} else if (ii < y.digits) {
			obliv unsigned short eresult = y.data[ii] + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		} else if ((ii >= x.digits && ii == y.digits) || (ii >= y.digits && ii == x.digits)) {
			out->data[ii] = rem;
		} else {
			out->data[ii] = 0;
		}
	}
}

void obig_sub_obliv(obig* out, obig x, obig y) obliv {
	obyte rem = 1;
	for (int ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits && ii < y.digits) {
			obliv unsigned short eresult = x.data[ii] + (y.data[ii] ^ 0xFF) + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		} else if (ii < x.digits) {
			obliv unsigned short eresult = x.data[ii] + 0xFF + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		} else if (ii < y.digits) {
			obliv unsigned short eresult = (y.data[ii] ^ 0xFF) + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		} else {
			obliv unsigned short eresult = 0xFF + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		}
	}
}

void obig_not_obliv(obig* out, obig x) obliv {
	for (int ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits) {
			out->data[ii] = ~x.data[ii];
		} else {
			out->data[ii] = 0xFF;
		}
	}
}

void obig_and_obliv(obig* out, obig x, obig y) obliv {
	for (int ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits && ii < y.digits) {
			out->data[ii] = x.data[ii] & y.data[ii];
		} else {
			out->data[ii] = 0;
		}
	}
}

void obig_or_obliv(obig* out, obig x, obig y) obliv {
	for (int ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits && ii < y.digits) {
			out->data[ii] = x.data[ii] | y.data[ii];
		} else if (ii < x.digits) {
			out->data[ii] = x.data[ii];
		} else if (ii < y.digits) {
			out->data[ii] = y.data[ii];
		} else {
			out->data[ii] = 0;
		}
	}
}

void obig_xor_obliv(obig* out, obig x, obig y) obliv {
	for (int ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits && ii < y.digits) {
			out->data[ii] = x.data[ii] ^ y.data[ii];
		} else if (ii < x.digits) {
			out->data[ii] = x.data[ii];
		} else if (ii < y.digits) {
			out->data[ii] = y.data[ii];
		} else {
			out->data[ii] = 0;
		}
	}
}	