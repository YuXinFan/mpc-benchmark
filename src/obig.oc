#include <stdint.h>

#include "obig.oh"

#define IS_BIG_ENDIAN (*(uint16_t *)"\0\xff" < 0x100)

/* Utility functions to be used only internally */

uint32_t ceildiv(uint32_t dividend, uint32_t divisor) {
	return (dividend + divisor - 1) / divisor; // ceil(dividend/divisor)
}

obliv bool obyte_msb_is_one(obliv uint8_t x) obliv {
	obliv bool result;
	//big_digit pattern = ~((big_digit)-1 >> 1);
	obliv if (x & 0x80 == 0) {
		result = 0;
	} else {
		result = 1;
	}
	return result;
}


/* memory management */

void obig_init(obig* x, size_t bytes) {
	x->digits = bytes; //ceildiv(bytes,sizeof(big_digit));
	x->data = malloc(sizeof(obliv uint8_t) * x->digits);
}

void obig_free(obig* x) {
	free(x->data);
	x->digits = 0;
	x->data = NULL;
}

void obig_resize(obig* x, size_t bytes) {
	obig temp;
	temp.digits = bytes; //ceildiv(bytes, sizeof(big_digit));
	temp.data = malloc(sizeof(obliv uint8_t) * temp.digits);

	obig_copy(&temp, *x);

	free(x->data);
	x->digits = temp.digits;
	x->data = temp.data;
}

void obig_resize_signed(obig* x, size_t bytes);
void obig_match_sizes(obig* x, obig* y);
void obig_match_sizes_signed(obig* x, obig* y);

void obig_copy(obig* out, obig in) obliv {
	for (size_t ii = 0; ii < out->digits; ii++) {
		if (ii < in.digits) {
			out->data[ii] = in.data[ii];
		} else {
			out->data[ii] = 0;
		}
	}
}

void obig_copy_signed(obig* out, obig in) obliv {
	if (out->digits > in.digits) {
		obliv bool inputIsNegative = obyte_msb_is_one(in.data[in.digits-1]);
		for (size_t ii = 0; ii < out->digits; ii++) {
			if (ii < in.digits) {
				out->data[ii] = in.data[ii];
			} else {
				// sign extend with MSB of input
				obliv if(inputIsNegative > 0) {
					out->data[ii] = -1;	
				} else {
					out->data[ii] = 0;
				}
			}
		}
	} else {
		for (size_t ii = 0; ii < out->digits; ii++) {
			out->data[ii] = in.data[ii];
		}
	}
}

/* convenience setters */

void obig_zero(obig* x) obliv {
	for (size_t ii = 0; ii < x->digits; ii++) {
		x->data[ii] = 0;
	}
}

void obig_one(obig* x) obliv {
	x->data[0] = 1;
	for (size_t ii = 1; ii < x->digits; ii++) {
		x->data[ii] = 0;
	}
}

void obig_set_onative(obig* x, obliv uint64_t y) obliv {
	for (size_t ii = 0; ii < x->digits; ii++) {
		if (ii < 16) {
			x->data[ii] = y >> (8 * ii);
		} else {
			x->data[ii] = 0;
		}
	}
}

void obig_set_onative_signed(obig* x, obliv int64_t y) obliv {
	for (size_t ii = 0; ii < x->digits; ii++) {
		if (ii < 16) {
			x->data[ii] = y >> (8 * ii);
		} else {
			obliv if (y < 0) {
				x->data[ii] = 0xFF;
			} else {
				x->data[ii] = 0;
			}
		}
	}
}

void obig_set_pointed(obig* x, void* p, size_t s) obliv {
	for (size_t ii = 0; ii < x->digits; ii++) {
		if (ii < s) {
			if (IS_BIG_ENDIAN) {
				x->data[x->digits - 1 - ii] = ((uint8_t*) p)[ii];
			} else {
				x->data[ii] = ((uint8_t*) p)[ii];
			}
		} else {
			x->data[ii] = 0;
		}
	}
}

/* comparators */

obliv bool obig_eq(obig x, obig y) obliv;
obliv bool obig_eq_signed(obig x, obig y) obliv;
obliv bool obig_gt(obig x, obig y) obliv;
obliv bool obig_gt_signed(obig x, obig y) obliv;
obliv bool obig_lt(obig x, obig y) obliv;
obliv bool obig_lt_signed(obig x, obig y) obliv;
obliv bool obig_gte(obig x, obig y) obliv;
obliv bool obig_gte_signed(obig x, obig y) obliv;
obliv bool obig_lte(obig x, obig y) obliv;
obliv bool obig_lte_signed(obig x, obig y) obliv;

obliv bool obig_gtz(obig x) obliv {
	obliv bool result = 0;
	for (size_t ii = 0; ii < x.digits; ii++) {
		obliv if (x.data[ii] > 0) {
			result = 1;
		}
	}
	return result;
}

obliv bool obig_gtz_signed(obig x) obliv {
	return (~(obig_ltz_signed(x) | obig_eqz(x))) & 1;
}

obliv bool obig_ltz_signed(obig x) obliv {
	return obyte_msb_is_one(x.data[x.digits - 1]);
}

obliv bool obig_eqz(obig x) obliv {
	obliv bool result = 1;
	for (size_t ii = 0; ii < x.digits; ii++) {
		obliv if (x.data[ii] != 0) {
			result = 0;
		}
	}
	return result;
}

obliv int8_t obig_cmp(obig x, obig y) obliv;
obliv int8_t obig_cmp_signed(obig x, obig y) obliv;

/* nondestructive elementary math */

void obig_shl1(obig* out, obig x) obliv {
	obliv uint8_t rem = 0;
	obliv uint8_t lastRem = 0;
	for (size_t ii = 0; ii < out->digits; ii++) {
		if (ii < x.digits) {
			rem = x.data[ii] & 0x80;
			obliv if (lastRem > 0) {
				out->data[ii] = (x.data[ii] << 1) | 1;
			} else {
				out->data[ii] = x.data[ii] << 1;
			}
			lastRem = rem;
		} else if (ii == x.digits) {
			obliv if (lastRem > 0) {
				out->data[ii] = 1;
			} else {
				out->data[ii] = 0;
			}
		} else {
			out->data[ii] = 0;
		}
	}
}

void obig_shl_native(obig* out, obig x, uint32_t y) obliv {
	if (y > 0) {
		obig_shl1(out, x);
	} else {
		obig_copy(out, x);
	}
	for (size_t ii = 1; ii < y; ii ++) {
		obig_shl1(out, *out);
	}
}

void obig_shl_onative(obig* out, obig x, obliv uint32_t y) obliv {
	obig_copy(out, x);
	for (size_t ii = 0; ii < x.digits; ii++) {
		obliv if (ii < y) {
			obig_shl1(out, *out);
		}
	}
}

void obig_shr1(obig* out, obig x) obliv {
	obliv uint8_t rem = 0;
	obliv uint8_t lastRem = 0;
	for (size_t ii = out->digits - 1; ii >= 0; ii--) {
		if (ii >= x.digits) {
			out->data[ii] = 0;
		} else {
			rem = x.data[ii] & 1;
			obliv if (lastRem > 0) {
				out->data[ii] = (x.data[ii] >> 1) | 0x80;
			} else {
				out->data[ii] = (x.data[ii] >> 1);
			}
			lastRem = rem;
		}
	}
}

void obig_shr_native(obig* out, obig x, uint32_t y) obliv {
	if (y > 0) {
		obig_shr1(out, x);
	} else {
		obig_copy(out, x);
	}
	for (uint32_t ii = 1; ii < y; ii ++) {
		obig_shr1(out, *out);
	}
}

void obig_shr_onative(obig* out, obig x, obliv uint32_t y) obliv {
	obig_copy(out, x);
	for (size_t ii = 0; ii < x.digits; ii++) {
		obliv if (ii < y) {
			obig_shr1(out, *out);
		}
	}
}

void obig_neg(obig* out, obig x) obliv {
	obliv uint8_t rem = 1;
	for (size_t ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits) {
			obliv uint16_t temp = (x.data[ii] ^ 0xFF) + rem;
			out->data[ii] = temp;
			rem = temp >> 8;
		} else {
			//obliv if (obyte_msb_is_one(x.data[x.digits - 1]) == 0) {
				obliv uint16_t temp = 0xFF + rem;
				out->data[ii] = temp;
				rem = temp >> 8;
			//} else {
			//	obliv uint16_t temp = 0x00 + rem;
			//	x.data[ii] = temp;
			//	rem = temp >> 8;
			//}
		}
	}
}

void obig_add(obig* out, obig x, obig y) obliv {
	obliv uint8_t rem = 0;
	for (size_t ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits && ii < y.digits) {
			obliv uint16_t eresult = x.data[ii] + y.data[ii] + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		} else if (ii < x.digits) {
			obliv uint16_t eresult = x.data[ii] + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		} else if (ii < y.digits) {
			obliv uint16_t eresult = y.data[ii] + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		} else if ((ii >= x.digits && ii == y.digits) || (ii >= y.digits && ii == x.digits)) {
			out->data[ii] = rem;
		} else {
			out->data[ii] = 0;
		}
	}
}

void obig_sub(obig* out, obig x, obig y) obliv {
	obliv uint8_t rem = 1;
	for (size_t ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits && ii < y.digits) {
			obliv uint16_t eresult = x.data[ii] + (y.data[ii] ^ 0xFF) + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		} else if (ii < x.digits) {
			obliv uint16_t eresult = x.data[ii] + 0xFF + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		} else if (ii < y.digits) {
			obliv uint16_t eresult = (y.data[ii] ^ 0xFF) + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		} else {
			obliv uint16_t eresult = 0xFF + rem;
			out->data[ii] = eresult;
			rem = eresult >> 8;
		}
	}
}

void obig_not(obig* out, obig x) obliv {
	for (size_t ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits) {
			out->data[ii] = ~x.data[ii];
		} else {
			out->data[ii] = 0xFF;
		}
	}
}

void obig_and(obig* out, obig x, obig y) obliv {
	for (size_t ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits && ii < y.digits) {
			out->data[ii] = x.data[ii] & y.data[ii];
		} else {
			out->data[ii] = 0;
		}
	}
}

void obig_or(obig* out, obig x, obig y) obliv {
	for (size_t ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits && ii < y.digits) {
			out->data[ii] = x.data[ii] | y.data[ii];
		} else if (ii < x.digits) {
			out->data[ii] = x.data[ii];
		} else if (ii < y.digits) {
			out->data[ii] = y.data[ii];
		} else {
			out->data[ii] = 0;
		}
	}
}

void obig_xor(obig* out, obig x, obig y) obliv {
	for (size_t ii = 0; ii < out->digits; ii ++) {
		if (ii < x.digits && ii < y.digits) {
			out->data[ii] = x.data[ii] ^ y.data[ii];
		} else if (ii < x.digits) {
			out->data[ii] = x.data[ii];
		} else if (ii < y.digits) {
			out->data[ii] = y.data[ii];
		} else {
			out->data[ii] = 0;
		}
	}
}	