#include "flatoram.oh"
#include "flatoram_util.oh"
#include "scanrom.oh"
#include "bitpropagate.oh"
#include "math.h"

#define BLOCKSIZE 16
#define KEYSIZE 16

struct flatoram {
	OcCopy* cpy;
	OcCopy* blockcpy;
	scanrom* writemem;
	scanrom* readmem;
	bitpropagator* bitpropagator;
	void* stash;
	obliv uint32_t* stashi;
	obliv bool* bitvector_data_temp;
	obliv bool* bitvector_flags_temp;
	void* romkey_local;
	void* wromkey_local;
	void* blocktemp;
	uint64_t period;
	uint64_t progress;
	uint64_t size;
	uint64_t blockcount;
	uint32_t blockmultiple;
	uint32_t elementsperblock;
};

void flatoram_read(void* data, scanram* ram, obliv uint32_t index) obliv {
	obliv uint32_t blockid = index / ram->elementsperblock;
	obliv uint32_t subblockid = index % ram->elementsperblock;
	bitpropagator_getonevector(ram->bitvector_data_temp, ram->bitpropagator, blockid);
	scanrom_read_with_bitvector(ram->blocktemp, ram->readmem, ram->bitvector_data_temp);
	for (uint32_t ii = 0; ii < ram->period; ii ++) {
		obliv if (blockid == ram->stashi[ii]) ocCopy(ram->blockcpy, ram->blocktemp, element(ram->blockcpy, ram->stash, ii));
	}
	for (uint32_t ii = 0; ii < ram->elementsperblock; ii ++) {
		obliv if (subblockid == ii) ocCopy(ram->cpy, data, element(ram->cpy, ram->blocktemp, ii));
	}
}

void flatoram_apply(flatoram* ram, void* data, flatoram_block_access_function fn, obliv uint32_t index) {
	obliv uint32_t blockid = index / ram->elementsperblock;
	obliv uint32_t subblockid = index % ram->elementsperblock;
	obliv bool found = false;

	if (ram->progress > 0) {
		ocCopy(ram->blockcpy, element(ram->blockcpy, ram->stash, ram->progress), element(ram->blockcpy, ram->stash, 0));
		ram->stashi[ram->progress] = ram->stashi[0];
		for (uint32_t ii = 1; ii < ram->period; ii ++) {
			obliv if (blockid == ram->stashi[ii]) {
				ocCopy(ram->blockcpy, element(ram->blockcpy, ram->stash, 0), element(ram->blockcpy, ram->stash, blockid));
				ram->stashi[0] = ram->stashi[ii];
				ram->stashi[ii] = -1;
				found = true;
			}
		}
	}

	bitpropagator_gettwovectors(ram->bitvector_data_temp, ram->bitvector_flags_temp, ram->bitpropagator, blockid, found);

	obliv if (~found) {
		scanrom_read_with_bitvector(element(ram->blockcpy, ram->stash, 0), ram->readmem, ram->bitvector_data_temp);
		ram->stashi[0] = blockid;
	}

	ocCopy(ram->blockcpy, ram->blocktemp, element(ram->blockcpy, ram->stash, 0));

	for (uint32_t jj = 0; ii < ram->elementsperblock; jj ++) {
		obliv if (subblockid == jj) fn(ram->cpy, element(ram->cpy, element(ram->blockcpy, ram->stash, 0), subblockid), data);
	}

	scanwrom_write_with_bitvectors(ram->writemem, element(ram->blockcpy, ram->stash, 0), ram->blocktemp, ram->bitvector_data_temp, ram->bitvector_flags_temp);

	ram->progress++;
	if (ram->progress == ram->period) flatoram_refresh(ram);
}

void writer_function(OcCopy * cpy, void * oram_block, void * ext_block) obliv {
  ocCopy(cpy, oram_block, ext_block);
}

void flatoram_write(scanram* ram, void* data, obliv uint32_t index) obliv {
	flatoram_apply(ram, data, writer_function, index);
}

void flatoram_refresh(flatoram* ram) {
	ram->progress = 0;
}

flatoram* flatoram_new(OcCopy* cpy, void* data, uint32_t n) {
	flatoram * ram = malloc(sizeof(flatoram));
	ram->cpy = cpy;
	ram->size = n;
	ram->progress = 0;

	size_t elementsize = cpy->eltsize/sizeof(obliv uint8_t);
	if (elementsize >= 8) {
		ram->blockcount = n;
		ram->blockmultiple = ((elementsize / BLOCKSIZE) + (elementsize%BLOCKSIZE?1:0));
		ram->elementsperblock = 1;
	} else {
		ram->blockmultiple = 1;
		ram->elementsperblock = BLOCKSIZE/elementsize;
		ram->blockcount = (n/ram->elementsperblock) + (n%ram->elementsperblock?1:0);
	}

	ram->blockcpy=ocCopyBoolN(ram->blockmultiple * BLOCKSIZE);

	ram->bitpropagator = bitpropagator_new(ram->blockcount, 0);
	ram->bitvector_data_temp = calloc(ram->blockcount, sizeof(obliv bool));
	ram->bitvector_flags_temp = calloc(ram->blockcount, sizeof(obliv bool));

	ram->period = (uint32_t)ceil(sqrt(ram->blockcount));
	ram->blocktemp = calloc(1, ram->blockcpy->eltsize);
	ram->stash = calloc(ram->period, ram->blockcpy->eltsize);
	ram->stashi = calloc(ram->period, sizeof(obliv uint32_t));

	//Set initial romkey and wromkey. Each party is expected to supply a different random value
	ram->romkey_local = malloc(KEYSIZE);
	ram->wromkey_local = malloc(KEYSIZE);
	get_random_bytes(ram->romkey_local, KEYSIZE);
	get_random_bytes(ram->wromkey_local, KEYSIZE);

	ram->readmem = scanrom_new(ram->blockcpy, ram->blockcount, ram->romkey_local);
	ram->writemem = scanwrom_new(ram->blockcpy, ram->blockcount, ram->wromkey_local);

	//Now fill the scanrom with data, if there is data with which to fill it
	if (data != NULL) {
		uint32_t blockid, subblockid;
		for (uint32_t ii = 0; ii < ram->size; ii++) {
			blockid = ii / ram->elementsperblock;
			subblockid = ii % ram->elementsperblock;
			ocCopy(cpy, element(cpy, ram->blocktemp, subblockid), element(cpy,data,ii));
			if (subblockid +1 == ram->elementsperblock) scanrom_write(ram->readmem, ram->blocktemp, blockid);
		}
		if (subblockid +1 != ram->elementsperblock) scanrom_write(ram->readmem, ram->blocktemp, blockid);
	}

	return ram;
}

void flatoram_free(flatoram* ram) {
	bitpropagator_free(ram->bitpropagator);
	scanrom_free(ram->readmem);
	scanwrom_free(ram->writemem);
	free(ram->blockcpy);
	free(ram->blocktemp);
	free(ram->romkey_local);
	free(ram->wromkey_local);
	free(ram->bitvector_data_temp);
	free(ram->bitvector_flags_temp);
	free(ram->stashi);
	free(ram->stash);
	free(ram);
}