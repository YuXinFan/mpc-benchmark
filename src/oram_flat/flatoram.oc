#include "flatoram.oh"
#include "flatoram_util.oh"
#include "scanrom.oh"
#include "bitpropagate.oh"

struct flatoram {
	OcCopy* cpy;
	OcCopy blockcpy;
	scanrom* writemem;
	scanrom* readmem;
	bitpropagator* bitpropagator;
	obliv uint8_t* stash;
	obliv uint32_t* stashi;
	obliv uint8_t* active_blocks_temp;
	uint8_t* blockvector_local_temp;
	uint8_t* romkey_local;
	obliv uint8_t* blocktemp;
	uint8_t* blocktemp_local;
	uint64_t period;
	uint64_t progress;
	uint64_t size;
	uint64_t blockcount;
	uint32_t blockmultiple;
	uint32_t elementsperblock;
};

void flatoram_read(void* data, flatoram* ram, obliv uint32_t index) obliv {
	obliv uint32_t blockid = index / ram->elementsperblock;
	obliv uint32_t subblockid = index % ram->elementsperblock;
	~obliv() bitpropagator_getblockvector(ram->active_blocks_temp, ram->blockvector_local_temp, ram->bitpropagator, blockid);
	scanrom_read_with_blockvector(ram->blocktemp, ram->readmem, blockid, ram->active_blocks_temp, ram->blockvector_local_temp);
	for (uint32_t ii = 0; ii < ram->period; ii ++) {
		obliv if (blockid == ram->stashi[ii]) ocCopy(&ram->blockcpy, ram->blocktemp, element(&ram->blockcpy, ram->stash, ii));
	}
	for (uint32_t ii = 0; ii < ram->elementsperblock; ii ++) {
		obliv if (subblockid == ii) ocCopy(ram->cpy, data, element(ram->cpy, ram->blocktemp, ii));
	}
}

void flatoram_refresh(flatoram* ram) {
	ram->progress = 0;
	get_random_bytes(ram->romkey_local, KEYSIZE);
	scanrom_set_key(ram->readmem, ram->romkey_local);
	scanrom_import_from_scanwrom(ram->readmem, ram->writemem);
	for (size_t ii = 0; ii < ram->period; ii++) {
		ram->stashi[ii] = -1;
	}
}

void flatoram_apply(flatoram* ram, void* data, flatoram_block_access_function fn, obliv uint32_t index) obliv {
	obliv uint32_t blockid = index / ram->elementsperblock;
	obliv uint32_t subblockid = index % ram->elementsperblock;
	obliv bool found = false;

	~obliv() {
		uint32_t temp;
		revealOblivInt(&temp, blockid, 0);
		printf("\tblock: %08X, ", temp);
		revealOblivInt(&temp, subblockid, 0);
		printf("subblock: %08X, ", temp);
		revealOblivInt(&temp, ram->progress, 0);
		printf("progress: %08X, ", temp);
	}

	~obliv() printf("\n\tSTASH SCAN\n");

	if (ram->progress > 0) {
		ocCopy(&ram->blockcpy, element(&ram->blockcpy, ram->stash, ram->progress), element(&ram->blockcpy, ram->stash, 0));
		ram->stashi[ram->progress] = ram->stashi[0];
		for (uint32_t ii = 1; ii < ram->period; ii ++) {
			obliv if (blockid == ram->stashi[ii]) {
				ocCopy(&ram->blockcpy, element(&ram->blockcpy, ram->stash, 0), element(&ram->blockcpy, ram->stash, ii));
				ram->stashi[0] = ram->stashi[ii];
				ram->stashi[ii] = -1;
				found = true;
			}
		}
	}

	~obliv() printf("\tFSS\n");

	~obliv() bitpropagator_getblockvector(ram->active_blocks_temp, ram->blockvector_local_temp, ram->bitpropagator, blockid);

	~obliv() printf("\tREAD\n");

	obliv if (~found) {
		scanrom_read_with_blockvector(element(&ram->blockcpy, ram->stash, 0), ram->readmem, blockid, ram->active_blocks_temp, ram->blockvector_local_temp);
		ram->stashi[0] = blockid;
	}

	ocCopy(&ram->blockcpy, ram->blocktemp, element(&ram->blockcpy, ram->stash, 0));

	~obliv() printf("\tAPPLY\n");

	for (uint32_t jj = 0; jj < ram->elementsperblock; jj ++) {
		obliv if (subblockid == jj) fn(ram->cpy, element(ram->cpy, element(&ram->blockcpy, ram->stash, 0), jj), data);
	}

	~obliv() printf("\tWRITE\n");

	scanwrom_write_with_blockvector(ram->writemem, ram->active_blocks_temp, ram->blockvector_local_temp, element(&ram->blockcpy, ram->stash, 0), ram->blocktemp);
	~obliv() {
		ram->progress++;
		if (ram->progress == ram->period) flatoram_refresh(ram);
	}
}

void writer_function(OcCopy * cpy, void * oram_block, void * ext_block) obliv {
  ocCopy(cpy, oram_block, ext_block);
}

void flatoram_write(flatoram* ram, void* data, obliv uint32_t index) obliv {
	flatoram_apply(ram, data, writer_function, index);
}

flatoram* flatoram_new(OcCopy* cpy, void* data, size_t n) {
	flatoram * ram = malloc(sizeof(flatoram));
	ram->cpy = cpy;
	ram->size = n;
	ram->progress = 0;

	size_t elementsize = cpy->eltsize/sizeof(obliv uint8_t);
	if (elementsize >= BLOCKSIZE/2) {
		ram->blockcount = n;
		ram->blockmultiple = ((elementsize / BLOCKSIZE) + (elementsize%BLOCKSIZE?1:0));
		ram->elementsperblock = 1;
	} else {
		ram->blockmultiple = 1;
		ram->elementsperblock = BLOCKSIZE/elementsize;
		ram->blockcount = (n/ram->elementsperblock) + (n%ram->elementsperblock?1:0);
	}

	ram->blockcpy=ocCopyBoolN(ram->blockmultiple * BLOCKSIZE);


	ram->bitpropagator = bitpropagator_new(ram->blockcount, MIN(6, LOG2(ram->blockcount)));
	ram->blockvector_local_temp = malloc(ram->blockcount * BLOCKSIZE);
	ram->blocktemp_local = malloc(ram->blockmultiple * BLOCKSIZE);
	ram->active_blocks_temp = calloc(2, BLOCKSIZE * sizeof(obliv uint8_t));

	ram->period = (uint32_t)ceil(sqrt(ram->blockcount));
	ram->blocktemp = calloc(1, ram->blockcpy.eltsize);
	ram->stash = calloc(ram->period, ram->blockcpy.eltsize);
	ram->stashi = calloc(ram->period, sizeof(obliv uint32_t));

	//Set initial romkey and wromkey. Each party is expected to supply a different random value
	ram->romkey_local = malloc(KEYSIZE);
	get_random_bytes(ram->romkey_local, KEYSIZE);

	ram->readmem = scanrom_new(&ram->blockcpy, ram->blockcount, ram->romkey_local);
	ram->writemem = scanwrom_new(&ram->blockcpy, ram->blockcount);

	//Now fill the scanrom with data, if there is data with which to fill it
	if (data != NULL) {
		uint32_t blockid, subblockid;
		for (uint32_t ii = 0; ii < ram->size; ii++) {
			blockid = ii / ram->elementsperblock;
			subblockid = ii % ram->elementsperblock;
			ocCopy(cpy, element(cpy, ram->blocktemp, subblockid), element(cpy,data,ii));
			if (subblockid +1 == ram->elementsperblock) {
				obliv uint32_t temp;
				for (size_t ii = 0; ii < (ram->blockmultiple * BLOCKSIZE)/sizeof(uint32_t); ii++) {
					temp = feedOblivInt(rand(),1);
					temp ^= feedOblivInt(rand(),2);
					revealOblivInt(&((uint32_t *)ram->blocktemp_local)[ii], temp, 1);
					revealOblivInt(&((uint32_t *)ram->blocktemp_local)[ii], ((obliv uint32_t *)ram->blocktemp)[ii]^temp, 2);
				}
				scanrom_write_xor_shares(ram->readmem, ram->blocktemp_local, blockid, 1);
				scanwrom_write_xor_shares(ram->readmem, ram->blocktemp_local, blockid, 1);
			}
		}
		if (subblockid +1 != ram->elementsperblock) {
			obliv uint32_t temp;
			for (size_t ii = 0; ii < (ram->blockmultiple * BLOCKSIZE)/sizeof(uint32_t); ii++) {
				temp = feedOblivInt(rand(),1);
				temp ^= feedOblivInt(rand(),2);
				revealOblivInt(&((uint32_t *)ram->blocktemp_local)[ii], temp, 1);
				revealOblivInt(&((uint32_t *)ram->blocktemp_local)[ii], ((obliv uint32_t *)ram->blocktemp)[ii]^temp, 2);
			}
			scanrom_write_xor_shares(ram->readmem, ram->blocktemp_local, blockid, 1);
			scanwrom_write_xor_shares(ram->readmem, ram->blocktemp_local, blockid, 1);
		}
	}

	return ram;
}

void flatoram_free(flatoram* ram) {
	bitpropagator_free(ram->bitpropagator);
	scanrom_free(ram->readmem);
	scanwrom_free(ram->writemem);
	free(ram->blocktemp);
	free(ram->blocktemp_local);
	free(ram->active_blocks_temp);
	free(ram->blockvector_local_temp);
	free(ram->romkey_local);
	free(ram->stashi);
	free(ram->stash);
	free(ram);
}