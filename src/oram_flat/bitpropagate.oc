#include "bitpropagate.oh"
#include "bitpropagate.h"
#include "flatoram_util.oh"
#include "ackutil.h"
#include <obliv.h>
#include <stdio.h>

struct bitpropagator {
	uint32_t startlevel;
	uint32_t endlevel;
	size_t size;
	obliv uint8_t * blocktemp_L;
	obliv uint8_t * blocktemp_R;
	obliv uint8_t * diff_L;
	obliv uint8_t * diff_R;
	obliv uint8_t * Z;
	obliv bool * advicebits;
	uint8_t * L_local;
	uint8_t * R_local;
	uint8_t * Z_local;
	bitpropagator_offline * bpo;
};

void bitpropagator_traverselevels(obliv uint8_t * active_block_delta, uint8_t * local_output, bool * local_bit_output, bitpropagator * bp, obliv size_t * indexp) {

	obliv uint32_t levelindex;
	obliv size_t index = *indexp;

	bitpropagator_offline_start(local_output, local_bit_output, bp->L_local, bp->R_local, bp->bpo);

	for (size_t ii = bp->startlevel+1; ii <= bp->endlevel; ii++) {

		levelindex = (index >> (bp->endlevel - ii)) & 1;

		feedOblivCharArray(bp->diff_L, bp->L_local, BLOCKSIZE, 1);
		feedOblivCharArray(bp->diff_R, bp->R_local, BLOCKSIZE, 1);
		feedOblivCharArray(bp->blocktemp_L, bp->L_local, BLOCKSIZE, 2);
		feedOblivCharArray(bp->blocktemp_R, bp->R_local, BLOCKSIZE, 2);
		for( size_t jj=0; jj< BLOCKSIZE/sizeof(uint64_t); jj++) {
			((obliv uint64_t *)bp->diff_L)[jj] ^= ((obliv uint64_t *)bp->blocktemp_L)[jj];
			((obliv uint64_t *)bp->diff_R)[jj] ^= ((obliv uint64_t *)bp->blocktemp_R)[jj];
		}
		
		obliv if (levelindex == 0) {
			ocCopyN(&ocCopyChar, bp->Z, bp->diff_R, BLOCKSIZE);
		} else {
			ocCopyN(&ocCopyChar, bp->Z, bp->diff_L, BLOCKSIZE);
		}

		bitpropagator_getadvice(bp->advicebits, bp->diff_L, bp->diff_R, levelindex);

		bool advicebit_L_local;
		bool advicebit_R_local;

		revealOblivBool(&advicebit_L_local, bp->advicebits[0], 2);
		revealOblivBool(&advicebit_R_local, bp->advicebits[1], 2);
		for( size_t jj=0; jj< BLOCKSIZE/sizeof(uint64_t); jj++) revealOblivLLong(&((uint64_t *)bp->Z_local)[jj], ((obliv uint64_t *)bp->Z)[jj], 2);
		revealOblivBool(&advicebit_L_local, bp->advicebits[0], 1);
		revealOblivBool(&advicebit_R_local, bp->advicebits[1], 1);
		for( size_t jj=0; jj< BLOCKSIZE/sizeof(uint64_t); jj++) revealOblivLLong(&((uint64_t *)bp->Z_local)[jj], ((obliv uint64_t *)bp->Z)[jj], 1);

		if (ii < bp->endlevel) {
			bitpropagator_offline_process_round(bp->L_local, bp->R_local, bp->Z_local, advicebit_L_local, advicebit_R_local, bp->bpo);	
		} else {
			bitpropagator_offline_finalize(bp->L_local, bp->Z_local, advicebit_L_local, advicebit_R_local, bp->bpo);
		}
	}

	feedOblivCharArray(active_block_delta, bp->L_local, BLOCKSIZE, 1);
	feedOblivCharArray(bp->blocktemp_L, bp->L_local, BLOCKSIZE, 2);
	for( size_t jj=0; jj< BLOCKSIZE/sizeof(uint64_t); jj++) {
		((obliv uint64_t *)active_block_delta)[jj] ^= ((obliv uint64_t *)bp->blocktemp_L)[jj];
	}
}

void bitpropagator_getblockvector(obliv uint8_t * active_block_delta, uint8_t * local_output, bool * local_bit_output, bitpropagator * bp, obliv size_t index) {
	bitpropagator_getblockvector_with_callback(active_block_delta, local_output, local_bit_output, bp, index, NULL, NULL);
}

void bitpropagator_getblockvector_with_callback(obliv uint8_t * active_block_delta, uint8_t * local_output, bool * local_bit_output, bitpropagator * bp, obliv size_t index, facb_fn cbfn, void* cbpass) {

#ifdef _OPENMP
	//This is a hack to work around the fact that openmp and obliv-c are incompatible.
	ProtocolDesc pd2;
	splitProtocol(&pd2, ocCurrentProto());
	bitpropagator_offline_parallelizer(bp, &index, active_block_delta, local_output, local_bit_output, &pd2, bitpropagator_traverselevels, cbfn, cbpass);
	cleanupProtocol(&pd2);
#else 
	bitpropagator_offline_parallelizer(bp, &index, active_block_delta, local_output, local_bit_output, NULL, bitpropagator_traverselevels, cbfn, cbpass);
#endif

}

void bitpropagator_getadvice(obliv bool * advicebits, obliv uint8_t * diff_L, obliv uint8_t * diff_R, obliv bool rightblock) {
	advicebits[0] = ((obliv bool *)diff_L)[0] ^ rightblock ^ 1;
	advicebits[1] = ((obliv bool *)diff_R)[0] ^ rightblock;
}

bitpropagator * bitpropagator_new(size_t size) {
	bitpropagator * bp = malloc(sizeof(bitpropagator));
	bp->size = size;
	bp->startlevel = 0;
	bp->endlevel = LOG2LL(size) + (((1ll << LOG2LL(size)) < size)? 1:0);
	bp->diff_L = calloc(1, BLOCKSIZE * sizeof(obliv uint8_t));
	bp->diff_R = calloc(1, BLOCKSIZE * sizeof(obliv uint8_t));
	bp->blocktemp_L = calloc(1, BLOCKSIZE * sizeof(obliv uint8_t));
	bp->blocktemp_R = calloc(1, BLOCKSIZE * sizeof(obliv uint8_t));
	bp->Z = calloc(1, BLOCKSIZE * sizeof(obliv uint8_t));
	bp->advicebits = calloc(1, 2*sizeof(obliv bool));
	bp->Z_local = malloc(BLOCKSIZE);
	flatoram_pma(&bp->L_local, 16, BLOCKSIZE);
	flatoram_pma(&bp->R_local, 16, BLOCKSIZE);

	//Generator chooses keys so that we don't incur round trips. Since we're semi-honest I guess it's OK? Should probably change it anyway.
	uint8_t * keyL = malloc(KEYSIZE);
	uint8_t * keyR = malloc(KEYSIZE);
	if (ocCurrentParty() == 1) {
		get_random_bytes(keyL, KEYSIZE);
		get_random_bytes(keyR, KEYSIZE);
		for (size_t ii=0; ii< KEYSIZE/sizeof(uint64_t);ii++) ocBroadcastLLong(((uint64_t *)keyL)[ii],1);
		for (size_t ii=0; ii< KEYSIZE/sizeof(uint64_t);ii++) ocBroadcastLLong(((uint64_t *)keyR)[ii],1);
	} else {
		for (size_t ii=0; ii< KEYSIZE/sizeof(uint64_t);ii++) ((uint64_t *)keyL)[ii] = ocBroadcastLLong(NULL,1);
		for (size_t ii=0; ii< KEYSIZE/sizeof(uint64_t);ii++) ((uint64_t *)keyR)[ii] = ocBroadcastLLong(NULL,1);
	}
	bp->bpo = bitpropagator_offline_new(size, keyL, keyR);
	free(keyL);
	free(keyR);

	return bp;
}

void bitpropagator_free(bitpropagator * bp) {
	free(bp->diff_L);
	free(bp->diff_R);
	free(bp->blocktemp_L);
	free(bp->blocktemp_R);
	free(bp->Z);
	free(bp->Z_local);
	free(bp->L_local);
	free(bp->R_local);
	free(bp->advicebits);
	bitpropagator_offline_free(bp->bpo);
	free(bp);
}