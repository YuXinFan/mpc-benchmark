#include "bitpropagate.oh"
#include "bitpropagate.h"
#include "flatoram_util.oh"
#include "ackutil.h"

struct bitpropagator {
	uint32_t startlevel;
	uint32_t endlevel;
	size_t size;
	obliv uint8_t * toplevel;
	uint8_t * toplevel_local;
	obliv uint8_t * blockzero;
	obliv uint8_t * blocktemp_A;
	obliv uint8_t * blocktemp_B;
	obliv uint8_t * activeblock_A;
	obliv uint8_t * activeblock_B;
	obliv uint8_t * expanded_A;
	obliv uint8_t * expanded_B;
	obliv uint8_t * Z;
	uint8_t * Z_local;
	bitpropagator_offline * bpo;
};

void bitpropagator_traverselevels(bitpropagator * bp, obliv size_t * indexp) {
	obliv uint32_t levelindex;
	obliv size_t index = *indexp;
	obliv bool control_bit_A_next, control_bit_B_next;
	obliv bool control_bit_A = ((obliv bool *)bp->activeblock_A)[0];
	obliv bool control_bit_B = ((obliv bool *)bp->activeblock_B)[0];

	for (size_t ii = bp->startlevel+1; ii <= bp->endlevel; ii++) {
		levelindex = (index >> (bp->endlevel - ii)) & 1;

		//first expand our active blocks into two blocks (L/R)
		online_expand(bp->expanded_A, bp->activeblock_A, 2);
		online_expand(bp->expanded_B, bp->activeblock_B, 2);
		obliv if (levelindex == 0) {
			//copy the branch to be kept
			ocCopyN(&ocCopyChar, bp->activeblock_A, bp->expanded_A, BLOCKSIZE);
			ocCopyN(&ocCopyChar, bp->activeblock_B, bp->expanded_B, BLOCKSIZE);
			//Z = block_A XOR block_B for the silenced branch
			ocCopyN(&ocCopyChar, bp->Z, &bp->expanded_A[BLOCKSIZE], BLOCKSIZE);
			for (size_t jj = 0; jj < BLOCKSIZE; jj ++) {
				bp->Z[jj] ^= bp->expanded_B[BLOCKSIZE+jj];
			}
		} else {
			//copy the branch to be kept
			ocCopyN(&ocCopyChar, bp->activeblock_A, &bp->expanded_A[BLOCKSIZE], BLOCKSIZE);
			ocCopyN(&ocCopyChar, bp->activeblock_B, &bp->expanded_B[BLOCKSIZE], BLOCKSIZE);
			//Z = block_A XOR block_B for the silenced branch
			ocCopyN(&ocCopyChar, bp->Z, bp->expanded_A, BLOCKSIZE);
			for (size_t jj = 0; jj < BLOCKSIZE; jj ++) {
				bp->Z[jj] ^= bp->expanded_B[jj];
			}
		}

		bool advicebit_local_l, advicebit_local_r;
		bitpropagator_getadvice(&advicebit_local_l, &advicebit_local_r, bp->expanded_A, bp->expanded_B, levelindex);

		for (size_t jj = 0; jj < BLOCKSIZE; jj++) revealOblivChar(&bp->Z_local[jj], bp->Z[jj], 1);
		for (size_t jj = 0; jj < BLOCKSIZE; jj++) revealOblivChar(&bp->Z_local[jj], bp->Z[jj], 2);

		bitpropagator_offline_push_Z(bp->bpo, bp->Z_local, advicebit_local_l, advicebit_local_r, ii);

		control_bit_A_next = control_bit_A;
		control_bit_B_next = control_bit_B;		

		obliv if (levelindex == 0) {
			control_bit_A_next &= advicebit_local_l;
			control_bit_B_next &= advicebit_local_l;	
		} else {
			control_bit_A_next &= advicebit_local_r;
			control_bit_B_next &= advicebit_local_r;
		}
		control_bit_A_next ^= ((obliv bool *)bp->activeblock_A)[0];
		control_bit_B_next ^= ((obliv bool *)bp->activeblock_B)[0];

		//XOR the live branches with Z if they will also be XORed by the offline component
		obliv if (control_bit_A) {
			for (size_t jj = 0; jj < BLOCKSIZE; jj ++) {
				bp->activeblock_A[jj] ^= bp->Z[jj];
			}
		}
		obliv if (control_bit_B) {
			for (size_t jj = 0; jj < BLOCKSIZE; jj ++) {
				bp->activeblock_B[jj] ^= bp->Z[jj];
			}
		}

		control_bit_A = control_bit_A_next;
		control_bit_B = control_bit_B_next;
	}
}

void bitpropagator_getblockvector(obliv uint8_t * activeblock_pair, uint8_t * local_output, bool * local_bit_output, bitpropagator * bp, obliv size_t index) {

	//Collect a set of random blocks for the top level
	get_random_bytes(bp->toplevel_local, ((1ll << bp->startlevel) + 1) * BLOCKSIZE);
	for (size_t ii = 0; ii < ((1ll << bp->startlevel) + 1) * BLOCKSIZE; ii++) bp->toplevel[ii] = feedOblivChar(bp->toplevel_local[ii], 1);
	for (size_t ii = 0; ii < ((1ll << bp->startlevel) + 1) * BLOCKSIZE; ii++) bp->toplevel[ii] ^= feedOblivChar(bp->toplevel_local[ii], 2);

	//now send identical blocks for all except the one branch that we're interested in.
	obliv size_t levelindex = index >> (bp->endlevel - bp->startlevel);

	for (size_t ii = 0; ii < (1ll << bp->startlevel); ii++) {
		ocCopyN(&ocCopyChar, &bp->blocktemp_A[ii*BLOCKSIZE], &bp->toplevel[ii * BLOCKSIZE], BLOCKSIZE);
		obliv if (levelindex != ii) {
			ocCopyN(&ocCopyChar, &bp->blocktemp_B[ii*BLOCKSIZE], &bp->toplevel[ii * BLOCKSIZE], BLOCKSIZE);
		} else {
			ocCopyN(&ocCopyChar, bp->activeblock_A, &bp->toplevel[ii * BLOCKSIZE], BLOCKSIZE);
			// ensure the root advice bits are opposite
			((obliv bool *)(&bp->toplevel[(1ll << bp->startlevel)*BLOCKSIZE]))[0] = ~((obliv bool *)bp->activeblock_A)[0];
			ocCopyN(&ocCopyChar, &bp->blocktemp_B[ii*BLOCKSIZE], &bp->toplevel[(1ll << bp->startlevel)*BLOCKSIZE], BLOCKSIZE);
		}
	}
	for (size_t ii = 0; ii < (1ll << bp->startlevel); ii++) for (size_t jj = 0; jj < BLOCKSIZE; jj++) revealOblivChar(&bp->toplevel_local[ii * BLOCKSIZE + jj], bp->blocktemp_A[ii * BLOCKSIZE + jj], 1);
	for (size_t ii = 0; ii < (1ll << bp->startlevel); ii++) for (size_t jj = 0; jj < BLOCKSIZE; jj++) revealOblivChar(&bp->toplevel_local[ii * BLOCKSIZE + jj], bp->blocktemp_B[ii * BLOCKSIZE + jj], 2);

	ocCopyN(&ocCopyChar, bp->activeblock_B, &bp->toplevel[(1ll << bp->startlevel)*BLOCKSIZE], BLOCKSIZE);

	bitpropagator_offline_start(bp->bpo, bp->toplevel_local);

	//This is a hack to work around the fact that openmp and obliv-c are incompatible.
	bitpropagator_offline_parallelizer(bp, bp->bpo, &index, local_output, local_bit_output, bitpropagator_traverselevels);

	//write output
	ocCopyN(&ocCopyChar, activeblock_pair, bp->activeblock_A, BLOCKSIZE);
	ocCopyN(&ocCopyChar, &activeblock_pair[BLOCKSIZE], bp->activeblock_B, BLOCKSIZE);
}

void bitpropagator_getadvice(bool * advicebit_local_l, bool * advicebit_local_r, obliv uint8_t * blocks_A, obliv uint8_t * blocks_B, obliv bool rightblock) {
	//uint8_t tlcw = (s0l[0]&0x1) ^ (s1l[0]&01) ^ ai ^ 1;
	//uint8_t trcw = (s0r[0]&0x1) ^ (s1r[0]&01) ^ ai;

	obliv bool advicebit_l = ((obliv bool *)blocks_A)[0] ^ ((obliv bool *)blocks_B)[0] ^ rightblock ^ 1;
	obliv bool advicebit_r = ((obliv bool *)blocks_A)[BLOCKSIZE*8] ^ ((obliv bool *)blocks_B)[BLOCKSIZE*8] ^ rightblock;
	revealOblivBool(advicebit_local_l, advicebit_l, 0);
	revealOblivBool(advicebit_local_r, advicebit_r, 0);
}

bitpropagator * bitpropagator_new(size_t size, uint32_t startlevel) {
	online_expand_init();
	bitpropagator * bp = malloc(sizeof(bitpropagator));
	bp->size = size;
	bp->endlevel = LOG2LL(size) + (((1ll << LOG2LL(size)) < size)? 1:0);
	bp->startlevel = MIN(startlevel,bp->endlevel-1);
	bp->toplevel = calloc((1ll << bp->startlevel) + 1, BLOCKSIZE * sizeof(obliv uint8_t));
	bp->toplevel_local = malloc(((1ll << bp->startlevel) + 1) * BLOCKSIZE);
	bp->blockzero = calloc(1, BLOCKSIZE * sizeof(obliv uint8_t));
	bp->blocktemp_A = calloc((1ll << bp->startlevel), BLOCKSIZE * sizeof(obliv uint8_t));
	bp->blocktemp_B = calloc((1ll << bp->startlevel), BLOCKSIZE * sizeof(obliv uint8_t));
	bp->activeblock_A = calloc(1, BLOCKSIZE * sizeof(obliv uint8_t));
	bp->activeblock_B = calloc(1, BLOCKSIZE * sizeof(obliv uint8_t));
	bp->expanded_A = calloc(2, BLOCKSIZE * sizeof(obliv uint8_t));
	bp->expanded_B = calloc(2, BLOCKSIZE * sizeof(obliv uint8_t));
	bp->Z = calloc(1, BLOCKSIZE * sizeof(obliv uint8_t));
	bp->Z_local = malloc(1 * BLOCKSIZE);
	bp->bpo = bitpropagator_offline_new(size, bp->startlevel);

	return bp;
}

void bitpropagator_free(bitpropagator * bp) {
	free(bp->toplevel);
	free(bp->toplevel_local);
	free(bp->blockzero);
	free(bp->blocktemp_A);
	free(bp->blocktemp_B);
	free(bp->activeblock_A);
	free(bp->activeblock_B);
	free(bp->expanded_A);
	free(bp->expanded_B);
	free(bp->Z);
	free(bp->Z_local);
	bitpropagator_offline_free(bp->bpo);
	online_expand_deinit();
	free(bp);
}