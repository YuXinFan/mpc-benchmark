#include "bitpropagate.oh"
#include "bitpropagate.h"
#include "flatoram_util.oh"

struct bitpropagator {
	uint32_t startlevel;
	uint32_t endlevel;
	size_t size;
	obliv uint8_t * toplevel;
	uint8_t * toplevel_local;
	obliv uint8_t * blockzero;
	obliv uint8_t * blocktemp_A;
	obliv uint8_t * blocktemp_B;
	obliv uint8_t * activeblock_A;
	obliv uint8_t * activeblock_B;
	obliv uint8_t * expanded_A;
	obliv uint8_t * expanded_B;
	obliv uint8_t * Z;
	uint8_t * Z_local;
	bitpropagator_offline * bpo;
};

void bitpropagator_traverselevels(bitpropagator * bp, obliv size_t * indexp) {
	obliv uint32_t levelindex;
	obliv size_t index = *indexp;

	for (size_t ii = bp->startlevel+1; ii <= bp->endlevel; ii++) {
		levelindex = (index >> (bp->endlevel - ii)) & 1;

		//first expand our active blocks into two blocks (L/R)
		online_expand(bp->expanded_A, bp->activeblock_A, 2);
		online_expand(bp->expanded_B, bp->activeblock_B, 2);
		obliv if (levelindex == 0) {
			//copy the branch to be silenced so that we can scan it for an advice bit
			ocCopyN(&ocCopyChar, bp->blocktemp_A, &bp->expanded_A[BLOCKSIZE], BLOCKSIZE);
			ocCopyN(&ocCopyChar, bp->blocktemp_B, &bp->expanded_B[BLOCKSIZE], BLOCKSIZE);
			//copy the branch to be kept
			ocCopyN(&ocCopyChar, bp->activeblock_A, bp->expanded_A, BLOCKSIZE);
			ocCopyN(&ocCopyChar, bp->activeblock_B, bp->expanded_B, BLOCKSIZE);
		} else {
			//copy the branch to be silenced so that we can scan it for an advice bit
			ocCopyN(&ocCopyChar, bp->blocktemp_A, bp->expanded_A, BLOCKSIZE);
			ocCopyN(&ocCopyChar, bp->blocktemp_B, bp->expanded_B, BLOCKSIZE);
			//copy the branch to be kept
			ocCopyN(&ocCopyChar, bp->activeblock_A, &bp->expanded_A[BLOCKSIZE], BLOCKSIZE);
			ocCopyN(&ocCopyChar, bp->activeblock_B, &bp->expanded_B[BLOCKSIZE], BLOCKSIZE);
		}

		//Z = block_A XOR block_B for the silenced branch
		ocCopyN(&ocCopyChar, bp->Z, bp->blocktemp_A, BLOCKSIZE);
		for (size_t jj = 0; jj < BLOCKSIZE; jj ++) {
			bp->Z[jj] ^= bp->blocktemp_B[jj];
		}

		for (size_t jj = 0; jj < BLOCKSIZE; jj++) {
			revealOblivChar(&bp->Z_local[jj], bp->Z[jj], 0);
		}

		int32_t advicebit_local = bitpropagator_getadvice(bp->blocktemp_A, bp->blocktemp_B);

		if (advicebit_local < 0) printf("CRITICAL ERROR! No advice recieved!");

		bitpropagator_offline_push_Z(bp->bpo, bp->Z_local, advicebit_local, ii);

		//XOR the live branches with Z if they will also be XORed by the offline component
		obliv if (((bp->activeblock_A[advicebit_local/8] >> advicebit_local%8) & 1) == 1) {
			for (size_t jj = 0; jj < BLOCKSIZE; jj ++) {
				bp->activeblock_A[jj] ^= bp->Z_local[jj];
			}
		}
		obliv if (((bp->activeblock_B[advicebit_local/8] >> advicebit_local%8) & 1) == 1) {
			for (size_t jj = 0; jj < BLOCKSIZE; jj ++) {
				bp->activeblock_B[jj] ^= bp->Z_local[jj];
			}
		}
	}
}

void bitpropagator_getblockvector(obliv uint8_t * activeblock_pair, uint8_t * local_output, bitpropagator * bp, obliv size_t index) {

	//Collect a set of random blocks for the top level
	get_random_bytes(bp->toplevel_local, ((1ll << bp->startlevel) + 1) * BLOCKSIZE);
	for (size_t ii = 0; ii < ((1ll << bp->startlevel) + 1) * BLOCKSIZE; ii++) {
		bp->toplevel[ii] = feedOblivChar(bp->toplevel_local[ii], 1);
		bp->toplevel[ii] ^= feedOblivChar(bp->toplevel_local[ii], 2);
	}

	//now send identical blocks for all except the one branch that we're interested in.
	obliv size_t levelindex = index >> (bp->endlevel - bp->startlevel);

	for (size_t ii = 0; ii < (1ll << bp->startlevel); ii++) {
		ocCopyN(&ocCopyChar, bp->blocktemp_A, &bp->toplevel[ii * BLOCKSIZE], BLOCKSIZE);
		obliv if (levelindex != ii) {
			ocCopyN(&ocCopyChar, bp->blocktemp_B, &bp->toplevel[ii * BLOCKSIZE], BLOCKSIZE);
		} else {
			ocCopyN(&ocCopyChar, bp->activeblock_A, &bp->toplevel[ii * BLOCKSIZE], BLOCKSIZE);
			ocCopyN(&ocCopyChar, bp->blocktemp_B, &bp->toplevel[(1ll << bp->startlevel)*BLOCKSIZE], BLOCKSIZE);
		}
		for (size_t jj = 0; jj < BLOCKSIZE; jj++) {
			revealOblivChar(&bp->toplevel_local[ii * BLOCKSIZE + jj], bp->blocktemp_A[jj], 1);
			revealOblivChar(&bp->toplevel_local[ii * BLOCKSIZE + jj], bp->blocktemp_B[jj], 2);
		}
	}
	ocCopyN(&ocCopyChar, bp->activeblock_B, &bp->toplevel[(1ll << bp->startlevel)*BLOCKSIZE], BLOCKSIZE);

	bitpropagator_offline_start(bp->bpo, bp->toplevel_local);

	//This is a hack to work around the fact that openmp and obliv-c are incompatible.
	bitpropagator_offline_parallelizer(bp, bp->bpo, &index, local_output, bitpropagator_traverselevels);

	//write output
	ocCopyN(&ocCopyChar, activeblock_pair, bp->activeblock_A, BLOCKSIZE);
	ocCopyN(&ocCopyChar, &activeblock_pair[BLOCKSIZE], bp->activeblock_B, BLOCKSIZE);
}

int32_t bitpropagator_getadvice(obliv uint8_t * activeblock_A, obliv uint8_t * activeblock_B) {
	obliv int32_t advicebit = -1;
	int32_t advicebit_local;
	for (size_t kk = 0; kk < BLOCKSIZE; kk ++) {
		for (uint8_t jj = 0; jj < 8; jj++) {
			obliv if (((activeblock_A[kk] >> jj) & 1) != (((activeblock_B[kk]) >> jj) & 1)) {
				advicebit = kk * 8 + jj;
			}
		}
	}
	revealOblivInt(&advicebit_local, advicebit, 0);
	return advicebit_local;
	//Note: if the advicebit is -1, we've found a collision in the PRG and must fail!
}

bitpropagator * bitpropagator_new(size_t size, uint32_t startlevel) {
	online_expand_init();
	bitpropagator * bp = malloc(sizeof(bitpropagator));
	bp->size = size;
	bp->endlevel = LOG2(size) + (((1ll << LOG2(size)) < size)? 1:0);
	bp->startlevel = MIN(startlevel,bp->endlevel-1);
	bp->toplevel = calloc((1ll << bp->startlevel) + 1, BLOCKSIZE * sizeof(obliv uint8_t));
	bp->toplevel_local = malloc(((1ll << bp->startlevel) + 1) * BLOCKSIZE);
	bp->blockzero = calloc(1, BLOCKSIZE * sizeof(obliv uint8_t));
	bp->blocktemp_A = calloc(1, BLOCKSIZE * sizeof(obliv uint8_t));
	bp->blocktemp_B = calloc(1, BLOCKSIZE * sizeof(obliv uint8_t));
	bp->activeblock_A = calloc(1, BLOCKSIZE * sizeof(obliv uint8_t));
	bp->activeblock_B = calloc(1, BLOCKSIZE * sizeof(obliv uint8_t));
	bp->expanded_A = calloc(2, BLOCKSIZE * sizeof(obliv uint8_t));
	bp->expanded_B = calloc(2, BLOCKSIZE * sizeof(obliv uint8_t));
	bp->Z = calloc(1, BLOCKSIZE * sizeof(obliv uint8_t));
	bp->Z_local = malloc(1 * BLOCKSIZE);
	bp->bpo = bitpropagator_offline_new(size, bp->startlevel);

	return bp;
}

void bitpropagator_free(bitpropagator * bp) {
	free(bp->toplevel);
	free(bp->toplevel_local);
	free(bp->blockzero);
	free(bp->blocktemp_A);
	free(bp->blocktemp_B);
	free(bp->activeblock_A);
	free(bp->activeblock_B);
	free(bp->expanded_A);
	free(bp->expanded_B);
	free(bp->Z);
	free(bp->Z_local);
	bitpropagator_offline_free(bp->bpo);
	online_expand_deinit();
	free(bp);
}