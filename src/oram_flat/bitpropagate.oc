#include "bitpropagate.oh"
#include "bitpropagate.h"
#include "flatoram_util.oh"

struct bitpropagator {
	uint32_t startlevel;
	uint32_t endlevel;
	size_t size;
	void * toplevel;
	void * toplevel_local;
	void * blockzero;
	void * blocktemp_A;
	void * blocktemp_B;
	void * activeblock_A;
	void * activeblock_B;
	void * expanded_A;
	void * expanded_B;
	void * Z;
	void * Z_local;
	bitpropagator_offline * bpo;
};

void bitpropagator_traverselevels(bitpropagator * bp, obliv uint32_t * indexp) {
	obliv uint32_t levelindex;
	obliv uint32_t index = *indexp;

	for (size_t ii = bp->startlevel+1; ii <= bp->endlevel; ii++) {
		levelindex = (index >> (bp->endlevel - ii)) & 1;

		//first expand our active blocks into two blocks (L/R)
		online_expand(bp->expanded_A, bp->activeblock_A, bp->blockzero, 2);
		online_expand(bp->expanded_B, bp->activeblock_B, bp->blockzero, 2);
		obliv if (levelindex == 0) {
			//copy the branch to be silenced so that we can scan it for an advice bit
			ocCopyN(&ocCopyChar, bp->blocktemp_A, element(&ocCopyChar, bp->expanded_A, BLOCKSIZE), BLOCKSIZE);
			ocCopyN(&ocCopyChar, bp->blocktemp_B, element(&ocCopyChar, bp->expanded_B, BLOCKSIZE), BLOCKSIZE);
			//copy the branch to be kept
			ocCopyN(&ocCopyChar, bp->activeblock_A, element(&ocCopyChar, bp->expanded_A, 0), BLOCKSIZE);
			ocCopyN(&ocCopyChar, bp->activeblock_B, element(&ocCopyChar, bp->expanded_B, 0), BLOCKSIZE);
		} else {
			//copy the branch to be silenced so that we can scan it for an advice bit
			ocCopyN(&ocCopyChar, bp->blocktemp_A, element(&ocCopyChar, bp->expanded_A, 0), BLOCKSIZE);
			ocCopyN(&ocCopyChar, bp->blocktemp_B, element(&ocCopyChar, bp->expanded_B, 0), BLOCKSIZE);
			//copy the branch to be kept
			ocCopyN(&ocCopyChar, bp->activeblock_A, element(&ocCopyChar, bp->expanded_A, BLOCKSIZE), BLOCKSIZE);
			ocCopyN(&ocCopyChar, bp->activeblock_B, element(&ocCopyChar, bp->expanded_B, BLOCKSIZE), BLOCKSIZE);
		}

		//Z = block_A XOR block_B for the silenced branch
		ocCopyN(&ocCopyChar, bp->Z, bp->blocktemp_A, BLOCKSIZE);
		for (size_t jj = 0; jj < BLOCKSIZE; jj ++) {
			*(obliv uint8_t*)element(&ocCopyChar, bp->Z, jj) ^= *(obliv uint8_t*)element(&ocCopyChar, bp->blocktemp_B, jj);
		}

		for (size_t jj = 0; jj < BLOCKSIZE; jj++) {
			revealOblivChar(&bp->Z_local[jj], *((obliv uint8_t *)element(&ocCopyChar, bp->Z, jj)), 0);
		}

		obliv int32_t advicebit = -1;
		for (size_t kk = 0; kk < BLOCKSIZE; kk ++) {
			for (uint8_t jj = 0; jj < 8; jj++) {
				obliv if ((((*(obliv uint8_t*)element(&ocCopyChar, bp->blocktemp_A, kk)) >> jj) & 1) != (((*(obliv uint8_t*)element(&ocCopyChar, bp->blocktemp_B, kk)) >> jj) & 1)) {
					advicebit = kk * 8 + jj;
				}
			}
		}
		int32_t advicebit_local;
		revealOblivInt(&advicebit_local, advicebit, 0);
		//Note: if the advicebit is -1, we've found a collision in the PRG and must fail!

		bitpropagator_offline_push_Z(bp->bpo, bp->Z_local, advicebit_local, ii);

		//XOR the live branches with Z if they will also be XORed by the offline component
		obliv if (((*(obliv uint8_t*)element(&ocCopyChar, bp->activeblock_A, advicebit_local/8) >> advicebit_local%8) & 1) == 1) {
			for (size_t jj = 0; jj < BLOCKSIZE; jj ++) {
				*(obliv uint8_t*)element(&ocCopyChar, bp->activeblock_A, jj) ^= ((uint8_t *)bp->Z_local)[jj];
			}
		}
		obliv if (((*(obliv uint8_t*)element(&ocCopyChar, bp->activeblock_B, advicebit_local/8) >> advicebit_local%8) & 1) == 1) {
			for (size_t jj = 0; jj < BLOCKSIZE; jj ++) {
				*(obliv uint8_t*)element(&ocCopyChar, bp->activeblock_B, jj) ^= ((uint8_t *)bp->Z_local)[jj];
			}
		}
	}
}

void bitpropagator_getblockvector(void * active_block_pair, void * local_output, bitpropagator * bp, obliv uint32_t index) {

	//Collect a set of random blocks for the top level
	get_random_bytes(bp->toplevel_local, ((1ll << bp->startlevel) + 1) * BLOCKSIZE);
	for (size_t ii = 0; ii < ((1ll << bp->startlevel) + 1) * BLOCKSIZE; ii++) {
		*(obliv uint8_t *)element(&ocCopyChar, bp->toplevel, ii) = feedOblivChar(((uint8_t *)bp->toplevel_local)[ii], 1);
		*(obliv uint8_t *)element(&ocCopyChar, bp->toplevel, ii) ^= feedOblivChar(((uint8_t *)bp->toplevel_local)[ii], 2);
	}

	//now send identical blocks for all except the one branch that we're interested in.
	obliv uint32_t levelindex = index >> (bp->endlevel - bp->startlevel);

	for (size_t ii = 0; ii < ((1ll << bp->startlevel)); ii++) {
		ocCopyN(&ocCopyChar, bp->blocktemp_A, element(&ocCopyChar, bp->toplevel, ii * BLOCKSIZE), BLOCKSIZE);
		obliv if (levelindex != ii) {
			ocCopyN(&ocCopyChar, bp->blocktemp_B, element(&ocCopyChar, bp->toplevel, ii * BLOCKSIZE), BLOCKSIZE);
		} else {
			ocCopyN(&ocCopyChar, bp->activeblock_A, element(&ocCopyChar, bp->toplevel, ii * BLOCKSIZE), BLOCKSIZE);
			ocCopyN(&ocCopyChar, bp->blocktemp_B, element(&ocCopyChar, bp->toplevel, ((1ll << bp->startlevel))), BLOCKSIZE);
		}
		for (size_t jj = 0; jj < BLOCKSIZE; jj++) {
			revealOblivChar(&bp->toplevel_local[ii * BLOCKSIZE + jj], *((obliv uint8_t *)element(&ocCopyChar, bp->blocktemp_A, jj)), 1);
			revealOblivChar(&bp->toplevel_local[ii * BLOCKSIZE + jj], *((obliv uint8_t *)element(&ocCopyChar, bp->blocktemp_B, jj)), 2);
		}
	}
	ocCopyN(&ocCopyChar, bp->activeblock_B, element(&ocCopyChar, bp->toplevel, ((1ll << bp->startlevel))), BLOCKSIZE);

	bitpropagator_offline_start(bp->bpo, bp->toplevel_local);

	//This is a hack to work around the fact that openmp and obliv-c are incompatible.
	bitpropagator_offline_parallelizer(bp, bp->bpo, &index, local_output, bitpropagator_traverselevels);

	//write output
	ocCopyN(&ocCopyChar, element(&ocCopyChar, active_block_pair, 0), bp->activeblock_A, BLOCKSIZE);
	ocCopyN(&ocCopyChar, element(&ocCopyChar, active_block_pair, BLOCKSIZE), bp->activeblock_B, BLOCKSIZE);
}

bitpropagator * bitpropagator_new(size_t size, uint32_t startlevel) {
	bitpropagator * bp = malloc(sizeof(bitpropagator));
	bp->size = size;
	bp->startlevel = startlevel;
	bp->endlevel = LOG2(size) + (((1ll << LOG2(size)) < size)? 1:0);
	bp->toplevel = calloc((1ll << bp->startlevel) + 1, BLOCKSIZE * sizeof(obliv uint8_t));
	bp->toplevel_local = malloc(((1ll << bp->startlevel) + 1) * BLOCKSIZE);
	bp->blockzero = calloc(1, BLOCKSIZE * sizeof(obliv uint8_t));
	bp->blocktemp_A = calloc(1, BLOCKSIZE * sizeof(obliv uint8_t));
	bp->blocktemp_B = calloc(1, BLOCKSIZE * sizeof(obliv uint8_t));
	bp->activeblock_A = calloc(1, BLOCKSIZE * sizeof(obliv uint8_t));
	bp->activeblock_B = calloc(1, BLOCKSIZE * sizeof(obliv uint8_t));
	bp->expanded_A = calloc(2, BLOCKSIZE * sizeof(obliv uint8_t));
	bp->expanded_B = calloc(2, BLOCKSIZE * sizeof(obliv uint8_t));
	bp->Z = calloc(1, BLOCKSIZE * sizeof(obliv uint8_t));
	bp->Z_local = malloc(1 * BLOCKSIZE);
	bp->bpo = bitpropagator_offline_new(size, startlevel);

	return bp;
}

void bitpropagator_free(bitpropagator * bp) {
	free(bp->toplevel);
	free(bp->toplevel_local);
	free(bp->blockzero);
	free(bp->blocktemp_A);
	free(bp->blocktemp_B);
	free(bp->activeblock_A);
	free(bp->activeblock_B);
	free(bp->expanded_A);
	free(bp->expanded_B);
	free(bp->Z);
	free(bp->Z_local);
	bitpropagator_offline_free(bp->bpo);
	free(bp);
}