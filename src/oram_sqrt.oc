#include "oram.oh"
#include "oram_sqrt/sqrtoram.oh"

struct oram {
	size_t size;
	size_t elct;
	OcCopy cpy;
	OcSqrtOram * data;
};

void oram_init(oram* o, size_t size, size_t elct, oram_base * src) {
	o->size = size;
	o->elct = elct;
	o->cpy = ocCopyIntN(elct);
	o->data = ocSqrtOramNew(&o->cpy, src, size);
}

oram * oram_new(size_t size, size_t elct) {
	oram * ram = malloc(sizeof(oram));
	oram_base * blank = calloc(size * elct, sizeof(oram_base));
	oram_init(ram, size, elct, blank);
	free(blank);
	return ram;
}

oram * oram_from_array(size_t size, size_t elct, oram_base * src) {
	oram * ram = malloc(sizeof(oram));
	oram_init(ram, size, elct, src);
	return ram;
}

void oram_free(oram* o) {
	ocSqrtOramRelease(o->data);
	o->size = 0;
	o->elct = 0;
	o->data = NULL;
	free(o);
}

obliv bool oram_read(oram_base * output, oram * o, obliv size_t index) {
	obliv bool success = false;

	obliv if ((index < o->size) & (index >= 0)) {
		ocSqrtOramReadObliv(o->data, index % o->size, output);
		success = true;
	}

	return success;
}

obliv bool oram_read_obliv(oram_base * output, oram * o, obliv size_t index) obliv {
	obliv bool success = false;

	obliv if ((index < o->size) & (index >= 0)) {
		ocSqrtOramReadObliv(o->data, index % o->size, output);
		success = true;
	}

	return success;
}

obliv bool oram_write(oram * o, oram_base * input, obliv size_t index) {
	obliv bool success = false;
	
	obliv if ((index < o->size) & (index >= 0)) {
		ocSqrtOramWriteObliv(o->data, input, index % o->size);
		success = true;
	}

	return success;
}

obliv bool oram_write_obliv(oram * o, oram_base * input, obliv size_t index) obliv {
	obliv bool success = false;
	
	obliv if ((index < o->size) & (index >= 0)) {
		ocSqrtOramWriteObliv(o->data, input, index % o->size);
		success = true;
	}

	return success;
}

obliv bool oram_apply(oram * o, oram_base * input, block_access_function fn, obliv size_t index) {
	obliv bool success = false;
	
	obliv if ((index < o->size) & (index >= 0)) {
		ocSqrtOramAccessObliv(o->data, index % o->size, fn, input);
		success = true;
	}

	return success;
}

obliv bool oram_apply_obliv(oram * o, oram_base * input, block_access_function fn, obliv size_t index) obliv {
	obliv bool success = false;
	
	obliv if ((index < o->size) & (index >= 0)) {
		ocSqrtOramAccessObliv(o->data, index % o->size, fn, input);
		success = true;
	}

	return success;
}
