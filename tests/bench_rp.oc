#include <obliv.oh>
#include "omatch.oh"
#include "oram.oh"
#include "osort.oh"
#include "test_generic.h"

#include <time.h>
#include <stdlib.h>

#define SAMPLES 30

static const char TESTNAME[] = "rp_benchmark";

char* testName() {
	return TESTNAME;
}

void shuffle(uint32_t *array, size_t n) {
    if (n > 1) {
        size_t i;
        for (i = 0; i < n - 1; i++) 
        {
          size_t j = i + rand() / (RAND_MAX / (n - i) + 1);
          int t = array[j];
          array[j] = array[i];
          array[i] = t;
        }
    }
}

int uint32cmp(const void *a,const void *b) {
	uint32_t *x = (uint32_t *) a;
	uint32_t *y = (uint32_t *) b;
	return *x - *y;
}

uint32_t unsafe_rand_range(uint32_t rangemin, uint32_t rangemax) {
	uint32_t result;
	if (rangemin == rangemax) {
		result = rangemin;
	} else {
		uint32_t rawrand = rand() & 0xff;
		rawrand |= (rand() & 0xff) << 8;
		rawrand |= (rand() & 0xff) << 16;
		rawrand |= (rand() & 0xff) << 24;
		result = (ocBroadcastInt(rawrand,1) % (rangemax - rangemin)) + rangemin;
	}
	return result;
}

static obliv char orp_pref_cmp(OcCopy * cpy, void * el1raw, void * el2raw) {
	//NOTE: DO NOT USE NEGATIVE VALUES FOR RID
	oroth_peranson_preference * el1 = ((oroth_peranson_preference *) el1raw);
	oroth_peranson_preference * el2 = ((oroth_peranson_preference *) el2raw);
	obliv int64_t result = ((((obliv int64_t) el1->rid) << 33) + (((obliv int64_t) el1->hid) << 1) + el1->is_h) - ((((obliv int64_t) el2->rid) << 33) + (((obliv int64_t) el2->hid) << 1) + el2->is_h);
	return (result > 0) | (-1 * (result < 0));
}

int pcts[] = {4,8,16,32,64,128,256,512,1024};
int pn = sizeof(pcts)/sizeof(pcts[0]);

void testMain(void*varg) {

	#ifdef ORAM_OVERRIDE
	oram_set_default_type(ORAM_OVERRIDE);
	#endif

	srand(time(NULL));

	fprintf(stdout, "==========\nROTH PERANSON (resident count, resident rankings bound, hospital count, hospital rankings bound, positions per hospital, sample 1, sample 2, ... sample n)\n----------\n");
	fflush(stdout);

	{

		for (int ii = 0; ii < pn; ii++) {
			int hospitals = pcts[ii];
			int residents = pcts[ii] * 8;
			int positions_min = 1;
			int positions_max = min(residents, 20);
			int hratings_per_position_min = 2;
			int hratings_per_position_max = 10;
			int rratings_min=min(hospitals, 5);
			int rratings_max=min(hospitals, 20);
			int hratings_max=min(residents, hratings_per_position_max*positions_max);

			uint64_t tally = 0;

			fprintf(stdout, "%d,%d,%d,%d,%d", residents, rratings_max, hospitals, hratings_max, positions_max);
			fflush(stdout);

			uint32_t * rperm = malloc(hospitals * sizeof(uint32_t));
			uint32_t * rperm2 = malloc(rratings_max * sizeof(uint32_t));
			for (int kk = 0; kk < hospitals; kk++) rperm[kk] = kk;
			for (int kk = 0; kk < rratings_max; kk++) rperm2[kk] = kk;

			uint32_t * hperm = malloc(residents * sizeof(uint32_t));
			uint32_t * hperm2 = malloc(hratings_max * sizeof(uint32_t));
			for (int kk = 0; kk < residents; kk++) hperm[kk] = kk;
			for (int kk = 0; kk < hratings_max; kk++) hperm2[kk] = kk;

			oroth_peranson_preference_share * r_prefs_a = calloc(residents*rratings_max, sizeof(oroth_peranson_preference_share));
			oroth_peranson_preference_share * r_prefs_b = calloc(residents*rratings_max, sizeof(oroth_peranson_preference_share));
			oroth_peranson_resident_share * r_data_a = calloc(residents, sizeof(oroth_peranson_resident_share));
			oroth_peranson_resident_share * r_data_b = calloc(residents, sizeof(oroth_peranson_resident_share));

			for (int kk = 0; kk < residents; kk++) {
				r_data_a[kk] = (oroth_peranson_resident_share) {
					.preferences = &r_prefs_a[kk*rratings_max],
					.preferences_bound = rratings_max
				};
				r_data_b[kk] = (oroth_peranson_resident_share) {
					.preferences = &r_prefs_b[kk*rratings_max],
					.preferences_bound = rratings_max
				};
			}

			oroth_peranson_preference_share * h_prefs_a = calloc(hospitals*hratings_max, sizeof(oroth_peranson_preference_share));
			oroth_peranson_preference_share * h_prefs_b = calloc(hospitals*hratings_max, sizeof(oroth_peranson_preference_share));
			oroth_peranson_hospital_share * h_data_a = calloc(hospitals, sizeof(oroth_peranson_hospital_share));
			oroth_peranson_hospital_share * h_data_b = calloc(hospitals, sizeof(oroth_peranson_hospital_share));

			for (int kk = 0; kk < hospitals; kk++) {
				h_data_a[kk] = (oroth_peranson_hospital_share) {
					.preferences = &h_prefs_a[kk*hratings_max],
					.preferences_bound = hratings_max,
					.positions_available_share = positions_max
				};
				h_data_b[kk] = (oroth_peranson_hospital_share) {
					.preferences = &h_prefs_b[kk*hratings_max],
					.preferences_bound = hratings_max,
					.positions_available_share = positions_max
				};
			}

			int samples = SAMPLES;

			for (int kk = 0; kk < samples; kk++) {
				for (int ll = 0; ll < residents; ll++) {
					uint32_t ratings = unsafe_rand_range(rratings_min, rratings_max);
					shuffle(rperm, hospitals);
					qsort(rperm, sizeof(uint32_t), ratings, uint32cmp);
					for (int jj = 0; jj < ratings; jj++) rperm2[jj] = jj;
					shuffle(rperm2, ratings);

					for (int jj = 0; jj < rratings_max; jj++) {
						uint32_t hid = rperm[jj];
						uint32_t rank;
						if (jj < ratings) {
							rank = rperm2[jj];	
						} else {
							rank = -1;	
						}
						uint32_t rnd_id = unsafe_rand_range(0, 0xFFFFFFFF);
						uint32_t rnd_rank = unsafe_rand_range(0, 0xFFFFFFFF);
						r_prefs_a[ll * rratings_max + jj].id_share = feedOblivInt(rnd_id, 1);
						r_prefs_b[ll * rratings_max + jj].id_share = feedOblivInt(rnd_id ^ hid, 2);
						r_prefs_a[ll * rratings_max + jj].rank_share = feedOblivInt(rnd_rank, 1);
						r_prefs_b[ll * rratings_max + jj].rank_share = feedOblivInt(rnd_rank ^ rank, 2);
					}
				}

				for (int ll = 0; ll < hospitals; ll++) {
					uint32_t positions = unsafe_rand_range(positions_min, positions_max);
					uint32_t rnd_positions = unsafe_rand_range(0, 0xFFFFFFFF);
					h_data_a[ll].positions_available_share = feedOblivInt(rnd_positions, 1);
					h_data_b[ll].positions_available_share = feedOblivInt(rnd_positions ^ positions, 2);

					uint32_t ratings = min(hratings_max, positions * unsafe_rand_range(hratings_per_position_min, hratings_per_position_max));
					shuffle(hperm, residents);
					qsort(hperm, sizeof(uint32_t), ratings, uint32cmp);
					for (int jj = 0; jj < ratings; jj++) hperm2[jj] = jj;
					shuffle(hperm2, ratings);

					for (int jj = 0; jj < hratings_max; jj++) {
						uint32_t rid = hperm[jj];
						uint32_t rank;
						if (jj < ratings) {
							rank = hperm2[jj];	
						} else {
							rank = -1;	
						}
						uint32_t rnd_id = unsafe_rand_range(0, 0xFFFFFFFF);
						uint32_t rnd_rank = unsafe_rand_range(0, 0xFFFFFFFF);
						h_prefs_a[ll * hratings_max + jj].id_share = feedOblivInt(rnd_id, 1);
						h_prefs_b[ll * hratings_max + jj].id_share = feedOblivInt(rnd_id ^ rid, 2);
						h_prefs_a[ll * hratings_max + jj].rank_share = feedOblivInt(rnd_rank, 1);
						h_prefs_b[ll * hratings_max + jj].rank_share = feedOblivInt(rnd_rank ^ rank, 2);
					}
				}

				uint64_t startTime = current_timestamp();
				oroth_peranson_preference_package * pkg = oroth_peranson_preference_package_from_shares(r_data_a, r_data_b, residents, h_data_a, h_data_b, hospitals, positions_max);
				oroth_peranson_output * output = oroth_peranson(pkg);
				uint64_t runtime = current_timestamp() - startTime;

				oroth_peranson_preference_package_free(pkg);
				oroth_peranson_output_free(output);
				free(pkg);
				free(output);

				fprintf(stdout, ",%llu", runtime);
				fflush(stdout);
				tally += runtime;

				
			}

			free(rperm);
			free(rperm2);
			free(hperm);
			free(hperm2);
			free(r_data_a);
			free(r_data_b);
			free(h_data_a);
			free(h_data_b);
			free(r_prefs_a);
			free(r_prefs_b);
			free(h_prefs_a);
			free(h_prefs_b);

			fprintf(stdout, "\n");
			fprintf(stderr, "ROTH PERANSON (residents:%d, resident rankings bound:%d, hospitals:%d, hospital rankings bound:%d, max positions:%d): %llu microseconds avg\n", residents, rratings_max, hospitals, hratings_max, positions_max, tally/samples);
		}

	}

}
