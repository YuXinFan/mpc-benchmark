#include <obliv.oh>
#include "oram_flat/bitpropagate.oh"
#include "oram_flat/bitpropagate.h"
#include "oram_flat/scanrom.oh"
#include <copy.oh>
#include "test_generic.h"

#define BLOCKCOUNT 64

static const char TESTNAME[] = "floram";

char* get_test_name() {
	return TESTNAME;
}

char* get_supplementary_options_string() {
	return NULL;
}

struct option* get_long_options() {
	return NULL;
}

void print_supplementary_help() {}



struct scanrom {
	OcCopy * blockcpy;
	uint8_t * local_data;
	uint8_t * local_halfkey;
	uint8_t * local_halfpad;
	obliv uint8_t * halfkey_a;
	obliv uint8_t * halfkey_b;
	uint8_t * local_blocktemp;
	obliv uint8_t * blocktemp;
	size_t blockmultiple;
	size_t blockcount;
	size_t fullblocksize;
};


void test_main(void*varg) {

	{

		size_t propagatorblocks = 2000;
		bitpropagator * bp = bitpropagator_new(propagatorblocks, 6);
		obliv uint8_t * active_block_pair = calloc(2, sizeof(obliv uint8_t) * 16);
		uint8_t * local_output;
		pma(&local_output, 16, propagatorblocks * 16);

		int64_t runtime = -current_timestamp();
		int64_t ygc = -yaoGateCount();
		bitpropagator_getblockvector(active_block_pair, local_output, bp, 943);
		runtime +=current_timestamp();
		ygc += yaoGateCount();

		/*printf("runtime: %d\n",runtime);
		printf("gates:   %d\n\b",ygc);
		
		printf("active 1: ");
		char temp;
		for (int ii = 0; ii < 16; ii++) {
			revealOblivChar(&temp,((obliv uint8_t *)active_block_pair)[ii],0);
			printf("%02hhX",temp);
		}
		printf("\nactive 2: ");
		for (int ii = 0; ii < 16; ii++) {
			revealOblivChar(&temp,((obliv uint8_t *)active_block_pair)[16+ii],0);
			printf("%02hhX",temp);
		}
		printf("\n");

		printf("local: \n");
		for (int ii = 0; ii < propagatorblocks; ii++) {
			printf("\t%08d: ",ii);
			for (int jj = 0; jj < 16; jj++) {
				printf("%02hhX",local_output[ii*16+jj]);
			}
			printf("\n");
		}*/
		
		OcCopy cpy = ocCopyCharN(16);
		obliv uint8_t * key_local = calloc(1, 16);
		for (int ii = 0; ii < (16)/sizeof(uint32_t); ii++) {
			((uint32_t *)key_local)[ii] = rand();
		}
		scanrom * rom = scanrom_new(&cpy, propagatorblocks, key_local);

		uint8_t * localdata = malloc(propagatorblocks * 16);
		obliv uint8_t * block = calloc(1, 16*sizeof(obliv uint8_t));
		bool * bitflags = malloc(propagatorblocks * sizeof(bool));
		for (int ii = 0; ii < (propagatorblocks * 16)/sizeof(uint32_t); ii++) {
			((uint32_t *)localdata)[ii] = rand();
		}

		scanrom_write_from_xor_shares(rom, localdata, 0, propagatorblocks);

		for (int ii=0; ii < 10; ii++) {
			obliv size_t index = feedOblivLLong(rand()%propagatorblocks, 1);
			size_t localindex;
			revealOblivLLong(&localindex, index, 0);
			printf("READ  RESULT TEST INDEX: %d", localindex);
			bitpropagator_getblockvector(active_block_pair, local_output, bp, index);
			int32_t advice = bitpropagator_getadvice(active_block_pair, &active_block_pair[16]);
			bitpropagator_offline_applyadvice(bitflags, local_output, 16, propagatorblocks, advice);

			/*printf("\n\tadvice: ");
			for(int jj = 0; jj < propagatorblocks; jj++) {
				printf("%d", bitflags[jj]);
			}*/

			scanrom_read_with_bitvector(block, rom, index, bitflags);
			printf("\n\tresult: ");
			for (int jj=0; jj<16;jj++) {
				uint8_t temp;
				revealOblivChar(&temp, block[jj], 0);
				printf("%02hhX", temp);
			}
			printf("\n\texpect: ");
			for (int jj=0; jj<16;jj++) {
				uint8_t temp = ocBroadcastChar(localdata[localindex * 16 + jj], 1);
				temp ^= ocBroadcastChar(localdata[localindex * 16 + jj], 2);
				printf("%02hhX", temp);
			}
			printf("\n");
		}

		bitpropagator_free(bp);
		scanrom_free(rom);
		
	}
	

	fprintf(stderr, "\n");

}