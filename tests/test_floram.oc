#include <obliv.oh>
#include "oram_flat/flatoram_util.h"
#include "oram_flat/bitpropagate.oh"
#include "oram_flat/flatoram.oh"
#include "oram_flat/bitpropagate.h"
#include "oram_flat/scanrom.oh"
#include <copy.oh>
#include "test_generic.h"

#define ELCT 256

static const char TESTNAME[] = "floram";

char* get_test_name() {
	return TESTNAME;
}

char* get_supplementary_options_string() {
	return NULL;
}

struct option* get_long_options() {
	return NULL;
}

void print_supplementary_help() {}

void shuffle(uint32_t *array, size_t n) {
	if (n > 1) {
		size_t i;
		for (i = 0; i < n - 1; i++) 
		{
		  size_t j = i + rand() / (RAND_MAX / (n - i) + 1);
		  int t = array[j];
		  array[j] = array[i];
		  array[i] = t;
		}
	}
}

struct scanrom {
	OcCopy * blockcpy;
	uint8_t * local_data;
	uint8_t * local_halfkey;
	uint8_t * local_halfpad;
	obliv uint8_t * halfkey_a;
	obliv uint8_t * halfkey_b;
	uint8_t * local_blocktemp;
	obliv uint8_t * blocktemp;
	size_t blockmultiple;
	size_t blockcount;
	size_t fullblocksize;
};

struct scanwrom {
	OcCopy * blockcpy;
	uint8_t * local_data;
	uint8_t * local_blocktemp;
	obliv uint8_t * blocktemp;
	size_t blockmultiple;
	size_t blockcount;
	size_t fullblocksize;
};

struct flatoram {
	OcCopy* cpy;
	OcCopy blockcpy;
	scanwrom* wrom;
	scanrom* rom;
	bitpropagator* bitpropagator;
	obliv uint8_t* stash;
	obliv uint32_t* stashi;
	obliv uint8_t* activeblock_pair;
	uint8_t* blockvector_local;
	uint8_t* rom_key_half;
	obliv uint8_t* blocktemp;
	uint8_t* blocktemp_local;
	uint64_t period;
	uint64_t progress;
	uint64_t size;
	uint64_t blockcount;
	uint32_t blockmultiple;
	uint32_t elementsperblock;
};

void test_main(void*varg) {

	{

		/*size_t propagatorblocks = 256;
		bitpropagator * bp = bitpropagator_new(propagatorblocks, MIN(6, LOG2(propagatorblocks)));
		obliv uint8_t * active_block_pair = calloc(2, sizeof(obliv uint8_t) * 16);
		uint8_t * local_output;
		pma(&local_output, 16, propagatorblocks * 16);*/

		//int64_t runtime = -current_timestamp();
		//int64_t ygc = -yaoGateCount();
		//bitpropagator_getblockvector(active_block_pair, local_output, bp, 943);
		//runtime +=current_timestamp();
		//ygc += yaoGateCount();

		/*printf("runtime: %d\n",runtime);
		printf("gates:   %d\n\b",ygc);
		
		printf("active 1: ");
		char temp;
		for (int ii = 0; ii < 16; ii++) {
			revealOblivChar(&temp,((obliv uint8_t *)active_block_pair)[ii],0);
			printf("%02hhX",temp);
		}
		printf("\nactive 2: ");
		for (int ii = 0; ii < 16; ii++) {
			revealOblivChar(&temp,((obliv uint8_t *)active_block_pair)[16+ii],0);
			printf("%02hhX",temp);
		}
		printf("\n");

		printf("local: \n");
		for (int ii = 0; ii < propagatorblocks; ii++) {
			printf("\t%08d: ",ii);
			for (int jj = 0; jj < 16; jj++) {
				printf("%02hhX",local_output[ii*16+jj]);
			}
			printf("\n");
		}*/
		
		/*OcCopy cpy = ocCopyCharN(16);
		obliv uint8_t * key_local = calloc(1, 16);
		for (int ii = 0; ii < (16)/sizeof(uint32_t); ii++) {
			((uint32_t *)key_local)[ii] = rand();
		}
		scanrom * rom = scanrom_new(&cpy, propagatorblocks, key_local);

		uint8_t * localdata = calloc(propagatorblocks, 16);
		obliv uint8_t * block = calloc(1, 16*sizeof(obliv uint8_t));
		for (int ii = 0; ii < (propagatorblocks * 16)/sizeof(uint32_t); ii++) {
			//if (ocCurrentParty() == 2) ((uint32_t *)localdata)[ii] = 0xDEADBEEF;
			((uint32_t *)localdata)[ii] = rand();
		}

		scanrom_write_xor_shares(rom, localdata, 0, propagatorblocks);

		uint64_t tally = 0;
		uint64_t tallygates = 0;

		int samples = 30;

		for (int ii=0; ii < samples; ii++) {
			obliv size_t index = feedOblivLLong(rand()%propagatorblocks, 1);

			int64_t runtime = -current_timestamp();
			int64_t rungates = -yaoGateCount();

			bitpropagator_getblockvector(active_block_pair, local_output, bp, index);

			scanrom_read_with_blockvector(block, rom, index, active_block_pair, local_output);

			size_t localindex;
			revealOblivLLong(&localindex, index, 0);
			for (size_t jj = 0; jj < 16; jj++ ) {
				uint8_t temp;
				revealOblivChar(&temp, block[jj],0);
				printf("%02hhX", temp);
			}
			
			printf("\n");
			for (size_t jj = 0; jj < 16; jj++ ) {
				printf("%02hhX", ocBroadcastChar(localdata[localindex*16+jj],1) ^ ocBroadcastChar(localdata[localindex*16+jj],2));
			}
			printf("\n");

			runtime += current_timestamp();
			rungates += yaoGateCount();

			//printf("Sample %d: %d microseconds, %d gates\n", ii, runtime, rungates);

			tally += runtime;
			tallygates += rungates;
		}

		printf("READ (n:%d): %d microseconds avg, %d gates avg\n", propagatorblocks, tally / samples, tallygates / samples);

		/*
		
		scanwrom * wrom = scanwrom_new(&cpy, propagatorblocks);

		memset(localdata, 0, propagatorblocks * 16);
		uint8_t * localblock = malloc(32);
		obliv uint8_t * zero = calloc(1, 16*sizeof(obliv uint8_t));
		for (int ii = 0; ii < (propagatorblocks * 16)/sizeof(uint32_t); ii++) {
			if (ocCurrentParty() == 1) ((uint32_t *)localdata)[ii] = 0xDEADBEEF;
		}

		tally = 0;
		tallygates = 0;

		for (int ii=0; ii < samples; ii++) {
			obliv size_t index = feedOblivLLong(rand()%propagatorblocks, 1);
			size_t localindex;
			revealOblivLLong(&localindex, index, 0);
			for (int jj = 0; jj < 16; jj++) {
				block[jj] = feedOblivChar(localdata[localindex*16+jj],1);
			}

			int64_t runtime = -current_timestamp();
			int64_t rungates = -yaoGateCount();

			bitpropagator_getblockvector(active_block_pair, local_output, bp, index);
			scanwrom_write_with_blockvector(wrom, active_block_pair, local_output, zero, block);

			runtime += current_timestamp();
			rungates += yaoGateCount();

			scanwrom_read(block, wrom, localindex);

			for (size_t jj = 0; jj < 16; jj++ ) {
				uint8_t temp;
				revealOblivChar(&temp, block[jj],0);
				printf("%02hhX", temp);
			}
			
			printf("\n");
			for (size_t jj = 0; jj < 16; jj++ ) {
				printf("%02hhX", ocBroadcastChar(localdata[localindex*16+jj],1));
			}
			printf("\n");

			//printf("Sample %d: %d microseconds, %d gates\n", ii, runtime, rungates);

			tally += runtime;
			tallygates += rungates;
		}

		printf("WRITE (n:%d): %d microseconds avg, %d gates avg\n", propagatorblocks, tally / samples, tallygates / samples);

		bitpropagator_free(bp);
		scanrom_free(rom);
		scanwrom_free(wrom);
		free(key_local);
		free(localdata);
		free(block);
		free(active_block_pair);
		free(local_output);
		free(localblock);
		free(zero);
		*/

		{
			uint32_t input_raw[ELCT];
			uint32_t order_raw[ELCT];

			for (int ii = 0; ii < ELCT; ii++) {
				input_raw[ii] = ii;
				order_raw[ii] = ii;
			}

			shuffle(order_raw, ELCT);

			flatoram * o = flatoram_new(&ocCopyInt, NULL, ELCT);

			for (int ii = 0; ii < ELCT; ii++) {
				obliv size_t index = feedOblivLLong(order_raw[ii], 1);
				obliv uint32_t value = feedOblivInt(input_raw[ii], 2);
				flatoram_write(o, &value, index);
			}

			bool success = true;

			for (int ii = 0; ii < ELCT; ii++) {
				uint32_t temp;
				obliv uint32_t value;
				obliv size_t index = feedOblivLLong(order_raw[ii], 1);
				flatoram_read(&value, o, index);
				revealOblivInt(&temp, value, 0);
				success &= (temp == input_raw[ii]);
			}

			flatoram_free(o);

			fprintf(stderr, "Test Item: %-19s %-50s %s\n", "Flatoram", "oram_write/oram_read", (success)?STATUS_SUCCESS:STATUS_FAILURE);

		}
		
	}
	

	fprintf(stderr, "\n");

}