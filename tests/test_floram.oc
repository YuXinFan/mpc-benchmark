#include <obliv.oh>
#include "oram_flat/bitpropagate.oh"
#include "oram_flat/bitpropagate.h"
#include "oram_flat/scanrom.oh"
#include <copy.oh>
#include "test_generic.h"

#define BLOCKCOUNT 64

static const char TESTNAME[] = "floram";

char* get_test_name() {
	return TESTNAME;
}

char* get_supplementary_options_string() {
	return NULL;
}

struct option* get_long_options() {
	return NULL;
}

void print_supplementary_help() {}



struct scanrom {
	OcCopy * blockcpy;
	uint8_t * local_data;
	uint8_t * local_halfkey;
	uint8_t * local_halfpad;
	obliv uint8_t * halfkey_a;
	obliv uint8_t * halfkey_b;
	uint8_t * local_blocktemp;
	obliv uint8_t * blocktemp;
	size_t blockmultiple;
	size_t blockcount;
	size_t fullblocksize;
};

struct scanwrom {
	OcCopy * blockcpy;
	uint8_t * local_data;
	uint8_t * local_blocktemp;
	obliv uint8_t * blocktemp;
	size_t blockmultiple;
	size_t blockcount;
	size_t fullblocksize;
};


void test_main(void*varg) {

	{

		size_t propagatorblocks = 200000;
		bitpropagator * bp = bitpropagator_new(propagatorblocks, 6);
		obliv uint8_t * active_block_pair = calloc(2, sizeof(obliv uint8_t) * 16);
		uint8_t * local_output;
		pma(&local_output, 16, propagatorblocks * 16);

		int64_t runtime = -current_timestamp();
		int64_t ygc = -yaoGateCount();
		bitpropagator_getblockvector(active_block_pair, local_output, bp, 943);
		runtime +=current_timestamp();
		ygc += yaoGateCount();

		/*printf("runtime: %d\n",runtime);
		printf("gates:   %d\n\b",ygc);
		
		printf("active 1: ");
		char temp;
		for (int ii = 0; ii < 16; ii++) {
			revealOblivChar(&temp,((obliv uint8_t *)active_block_pair)[ii],0);
			printf("%02hhX",temp);
		}
		printf("\nactive 2: ");
		for (int ii = 0; ii < 16; ii++) {
			revealOblivChar(&temp,((obliv uint8_t *)active_block_pair)[16+ii],0);
			printf("%02hhX",temp);
		}
		printf("\n");

		printf("local: \n");
		for (int ii = 0; ii < propagatorblocks; ii++) {
			printf("\t%08d: ",ii);
			for (int jj = 0; jj < 16; jj++) {
				printf("%02hhX",local_output[ii*16+jj]);
			}
			printf("\n");
		}*/
		
		OcCopy cpy = ocCopyCharN(16);
		/*obliv uint8_t * key_local = calloc(1, 16);
		for (int ii = 0; ii < (16)/sizeof(uint32_t); ii++) {
			((uint32_t *)key_local)[ii] = rand();
		}
		scanrom * rom = scanrom_new(&cpy, propagatorblocks, key_local);

		uint8_t * localdata = malloc(propagatorblocks * 16);
		obliv uint8_t * block = calloc(1, 16*sizeof(obliv uint8_t));
		for (int ii = 0; ii < (propagatorblocks * 16)/sizeof(uint32_t); ii++) {
			((uint32_t *)localdata)[ii] = rand();
		}

		scanrom_write_from_xor_shares(rom, localdata, 0, propagatorblocks);

		uint64_t tally = 0;
		uint64_t tallygates = 0;

		int samples = 30;

		for (int ii=0; ii < samples; ii++) {
			obliv size_t index = feedOblivLLong(rand()%propagatorblocks, 1);

			int64_t runtime = -current_timestamp();
			int64_t rungates = -yaoGateCount();

			bitpropagator_getblockvector(active_block_pair, local_output, bp, index);

			scanrom_read_with_blockvector(block, rom, index, active_block_pair, local_output);

			runtime += current_timestamp();
			rungates += yaoGateCount();

			printf("Sample %d: %d microseconds, %d gates\n", ii, runtime, rungates);

			tally += runtime;
			tallygates += rungates;
		}*/

		scanwrom * rom = scanwrom_new(&cpy, propagatorblocks);

		uint8_t * localdata = calloc(1, propagatorblocks * 16);
		uint8_t * localblock = malloc(32);
		obliv uint8_t * block = calloc(1, 16*sizeof(obliv uint8_t));
		obliv uint8_t * zero = calloc(1, 16*sizeof(obliv uint8_t));
		for (int ii = 0; ii < (propagatorblocks * 16)/sizeof(uint32_t); ii++) {
			if (ocCurrentParty() == 1) ((uint32_t *)localdata)[ii] = 0xDEADBEEF;
		}

		uint64_t tally = 0;
		uint64_t tallygates = 0;

		int samples = 30;

		for (int ii=0; ii < samples; ii++) {
			obliv size_t index = feedOblivLLong(rand()%propagatorblocks, 1);
			size_t localindex;
			revealOblivLLong(&localindex, index, 0);
			for (int jj = 0; jj < 16; jj++) {
				block[jj] = feedOblivChar(localdata[localindex*16+jj],1);
			}

			int64_t runtime = -current_timestamp();
			int64_t rungates = -yaoGateCount();

			bitpropagator_getblockvector(active_block_pair, local_output, bp, index);
			scanwrom_write_with_blockvector(rom, active_block_pair, local_output, zero, block);

			runtime += current_timestamp();
			rungates += yaoGateCount();

			scanwrom_read(block, rom, localindex);

			for (size_t jj = 0; jj < 16; jj++ ) {
				uint8_t temp;
				revealOblivChar(&temp, block[jj],0);
				printf("%02hhX", temp);
			}
			printf("\n");
			for (size_t jj = 0; jj < 16; jj++ ) {
				printf("%02hhX", ocBroadcastChar(localdata[localindex*16+jj],1));
			}
			printf("\n");

			printf("Sample %d: %d microseconds, %d gates\n", ii, runtime, rungates);

			tally += runtime;
			tallygates += rungates;
		}

		printf("(n:%d): %d microseconds avg, %d gates avg\n", propagatorblocks, tally / samples, tallygates / samples);

		bitpropagator_free(bp);
		scanwrom_free(rom);
		
	}
	

	fprintf(stderr, "\n");

}