#include <obliv.oh>
#include "osearch.oh"
#include "test_generic.h"

#define SAMPLES 30

static const char TESTNAME[] = "obst_benchmark";

char* testName() {
	return TESTNAME;
}

obliv int cmpInt(OcCopy * cpy, void * a, void * b) obliv {
	obliv uint32_t * aa = (obliv uint32_t *) a;
	obliv uint32_t * bb = (obliv uint32_t *) b;
	return (*aa > *bb) - (*aa < *bb);
}

int elcts[] = {32,1024,32768};
int searchcts[] = {1,2,4,8,16,32,64,128,256,512,1024};
int en = sizeof(elcts)/sizeof(elcts[0]);
int sn = sizeof(searchcts)/sizeof(searchcts[0]);

void testMain(void*varg) {

	fprintf(stdout, "==========\nBINARY SEARCH (elements, searches, sample 1, sample 2, ... sample n)\n----------\n");
	fflush(stdout);

	{
		OcCopy cpy = ocCopyIntN(4);

		for (int ii = 0; ii < en; ii++) {
			int elct = elcts[ii];
			for (int jj = 0; jj < sn; jj++) {
				int searchct = searchcts[jj];

				uint64_t tally = 0;

				fprintf(stdout, "%d,%d", elct, searchct);
				fflush(stdout);

				obliv uint32_t * input = calloc(elct, 4*sizeof(obliv uint32_t));
				obliv uint32_t output;
				obliv uint32_t needle;
				obliv uint32_t otemp;

				int samples = elct < 2048 ? SAMPLES : 3;

				for (int kk = 0; kk < samples; kk++) {

					otemp = 0;
					for (int ll = 0; ll < elct; ll++) {
						otemp += feedOblivInt(rand()%8, ll%2);
						input[4*ll] = otemp;
					}

					uint64_t startTime = current_timestamp();

					oram * o = oram_from_array(ORAM_TYPE_AUTO, &cpy, elct, input);

					for (int ll = 0; ll < searchct; ll++) {
						needle = input[4 * ocBroadcastInt(rand()%elct, 1)];
						obinary_search_oram(&cpy, &output, o, &needle, &cmpInt);
					}
					oram_free(o);

					uint64_t runtime = current_timestamp() - startTime;

					fprintf(stdout, ",%d", runtime);
					fflush(stdout);
					tally += runtime;

					
				}

				free(input);

				fprintf(stdout, "\n");
				fprintf(stderr, "BINARY SEARCH (elements:%d, searches:%d): %d microseconds avg\n", elct, searchct, tally/samples);
			}
		}

	}

}
