#include <obliv.oh>
#include "oram.oh"
#include "copy.oh"
#include "test_generic.h"

#define SAMPLES 1000

static const char TESTNAME[] = "oram_benchmark";

char* testName() {
	return TESTNAME;
}

int elcts[] = {4,8,16,32,64,128,256,512,1024};
int elszs[] = {1,2,4,8,16,32,64,128,256};
int en = sizeof(elcts)/sizeof(elcts[0]);
int sn = sizeof(elszs)/sizeof(elszs[0]);

void testMain(void*varg) {

	#ifdef ORAM_OVERRIDE
	oram_set_default_type(ORAM_OVERRIDE);
	#endif

	fprintf(stdout, "==========\nORAM ACCESS (WRITE) (elct, elsz, sample 1, sample 2, ... sample n)\n----------\n");

	for (int ii = 0; ii < en; ii++) {
		int elct = elcts[ii];
		for (int jj = 0; jj < sn; jj++) {
			int elsz = elszs[jj];

			OcCopy cpy = ocCopyIntN(elsz);

			uint64_t tally = 0;
			obliv uint32_t * input = calloc(elsz * elct, sizeof(obliv uint32_t));
			for (int kk = 0; kk < (elsz * elct); kk++) input[kk] = feedOblivInt(rand(), 1);

			oram * o = oram_new(ORAM_TYPE_AUTO, &cpy, elct);

			fprintf(stdout, "%d,%d", elct, elsz);

			for (int kk = 0; kk < SAMPLES; kk++) {
				uint32_t index_raw = ocBroadcastInt(rand() % elct, 2);
				obliv uint32_t index = feedOblivInt(index_raw, 2);
				uint64_t startTime = current_timestamp();
				oram_write(o, &input[index_raw*elsz], index);
				uint64_t runtime = current_timestamp() - startTime;
				fprintf(stdout, ",%d", runtime);
				fflush(stdout);
				tally += runtime;
			}

			free(input);
			oram_free(o);
			fprintf(stdout, "\n");
			fprintf(stderr, "Write (count:%d, size: %d): %d microseconds avg\n", elct, elsz, tally / (SAMPLES));

		}
	}

}
