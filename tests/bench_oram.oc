#include <time.h>
#include <stdio.h>
#include <obliv.oh>
#include <stdbool.h>
#include <stdlib.h>
#include <time.h>

#include "util.h"
#include "oram.oh"
#include "copy.oh"
#include "test_generic.h"

#define SAMPLES 1000

static const char TESTNAME[] = "oram_benchmark";

char* testName() {
	return TESTNAME;
}

int elcts[9] = {4,8,16,32,64,128,256,512,1024};
int elszs[9] = {1,2,4,8,16,32,64,128,256};

void testMain(void*varg) {

	fprintf(stdout, "==========\nORAM ACCESS (WRITE) (elct, elsz, sample 1, sample 2, ... sample n)\n----------\n");

	for (int ii = 0; ii < 9; ii++) {
		int elct = elcts[ii];
		for (int jj = 0; jj < 9; jj++) {
			int elsz = elszs[jj];

			OcCopy cpy = ocCopyIntN(elsz);

			uint64_t tally = 0;
			obliv uint32_t * input = calloc(elsz * elct, sizeof(obliv uint32_t));
			for (int kk = 0; kk < (elsz * elct); kk++) input[kk] = feedOblivInt(rand(), 1);

			oram * o = oram_new(ORAM_TYPE_AUTO, &cpy, elct);

			fprintf(stdout, "%d,%d", elct, elsz);

			for (int kk = 0; kk < SAMPLES; kk++) {
				uint32_t index_raw = ocBroadcastInt(rand() % elct, 2);
				obliv uint32_t index = feedOblivInt(index_raw, 2);
				uint64_t startTime = current_timestamp();
				oram_write(o, &input[index_raw*elsz], index);
				uint64_t endTime = current_timestamp();
				fprintf(stdout, ",%d", endTime - startTime);
				tally += endTime - startTime;
			}

			free(input);
			oram_free(o);
			fprintf(stdout, "\n");
			fprintf(stderr, "Write (count:%d, size: %d): %d microseconds avg\n", elct, elsz, tally / (SAMPLES));

		}
	}

}
