#include <time.h>
#include <stdio.h>
#include <obliv.oh>
#include <stdbool.h>
#include <stdlib.h>
#include <time.h>

#include "oram.oh"
#include "test_generic.h"

#define SAMPLES 3000

static const char TESTNAME[] = "oram_benchmark";

char* testName() {
	return TESTNAME;
}

int elcts[9] = {4,8,16,32,64,128,256,512,1024};
int elszs[9] = {1,2,4,8,16,32,64,128,256};

uint64_t GetTimeStamp() {
    struct timeval tv;
    gettimeofday(&tv,NULL);
    return tv.tv_sec*(uint64_t)1000000+tv.tv_usec;
}

void testMain(void*varg) {

	fprintf(stdout, "==========\nORAM ACCESS (WRITE) (elct, elsz, sample 1, sample 2, ... sample n)\n----------\n");

	for (int ii = 0; ii < 9; ii++) {
		int elct = elcts[ii];
		for (int jj = 0; jj < 9; jj++) {
			int elsz = elszs[jj];

			uint64_t tally = 0;
			obliv uint32_t * input = calloc(elsz * elct, sizeof(obliv uint32_t));
			for (int kk = 0; kk < (elsz * elct); kk++) input[kk] = feedOblivInt(rand(), 1);

			oram * o = oram_new(elct, elsz);

			fprintf(stdout, "%d,%d", elct, elsz);

			for (int kk = 0; kk < SAMPLES; kk++) {
				uint32_t index_raw = ocBroadcastInt(rand() % elct, 2);
				obliv uint32_t index = feedOblivInt(index_raw, 2);
				uint64_t startTime = GetTimeStamp();
				oram_write(o, &input[index_raw*elsz], index);
				uint64_t endTime = GetTimeStamp();
				fprintf(stdout, ",%d", endTime - startTime);
				tally += endTime - startTime;
			}

			free(input);
			oram_free(o);
			fprintf(stdout, "\n");
			fprintf(stderr, "Write (count:%d, size: %d): %d microseconds avg\n", elct, elsz, tally / (SAMPLES));

		}
	}

	/*fprintf(stdout, "==========\nORAM READ (elct, elsz, sample 1, sample 2, ... sample n)\n----------\n");

	for (int ii = 0; ii < 9; ii++) {
		int elct = elcts[ii];
		for (int jj = 0; jj < 9; jj++) {
			int elsz = elszs[jj];

			uint64_t tally = 0;
			obliv uint32_t * output = calloc(elsz, sizeof(obliv uint32_t));

			oram * o = oram_new(elct, elsz);

			for (int index=0; index < elct; index++) {
				for (int kk = 0; kk < elsz; kk++) output[kk] = feedOblivInt(rand(), 1);
				oram_write(o, output, index);
			}

			fprintf(stdout, "%d,%d", elct, elsz);

			for (int kk = 0; kk < SAMPLES; kk++) {
				obliv uint32_t index = feedOblivInt(rand() % elct, 2);
				uint64_t startTime = GetTimeStamp();
				oram_read(output, o, index);
				uint64_t endTime = GetTimeStamp();
				fprintf(stdout, ",%d", endTime - startTime);
				tally += endTime - startTime;
			}

			free(output);
			oram_free(o);
			fprintf(stdout, "\n");
			fprintf(stderr, "Read (count:%d, size: %d): %d microseconds avg\n", elct, elsz, tally / (SAMPLES));

		}
	}*/

}
