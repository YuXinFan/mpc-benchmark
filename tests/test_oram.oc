#include <obliv.oh>
#include "oram.oh"
#include "test_generic.h"

static const char TESTNAME[] = "oram";

char* testName() {
	return TESTNAME;
}

void shuffle(uint32_t *array, size_t n) {
    if (n > 1) {
        size_t i;
        for (i = 0; i < n - 1; i++) 
        {
          size_t j = i + rand() / (RAND_MAX / (n - i) + 1);
          int t = array[j];
          array[j] = array[i];
          array[i] = t;
        }
    }
}

const char* getOramName(oram_type mode) {
	switch (mode) {
		case ORAM_TYPE_SQRT:
			return "Square-Root ORAM:";
		case ORAM_TYPE_CIRCUIT:
			return "Circuit ORAM:";
		case ORAM_TYPE_LINEAR:
			return "Linear Scan:";
		default:
			return "Unknown";
	}
}

void testOramType(oram_type mode) {

	{
		uint32_t input_raw[256];
		uint32_t order_raw[256];

		for (int ii = 0; ii < 256; ii++) {
			input_raw[ii] = ii;
			order_raw[ii] = ii;
		}

		shuffle(order_raw, 256);

		oram * o = oram_new(mode, &ocCopyInt, 256);

		for (int ii = 0; ii < 256; ii++) {
			obliv size_t index = feedOblivLong(order_raw[ii], 1);
			obliv uint32_t value = feedOblivInt(input_raw[ii], 2);
			oram_write(o, &value, index);
		}

		bool success = true;

		for (int ii = 0; ii < 256; ii++) {
			uint32_t temp;
			obliv uint32_t value;
			obliv size_t index = feedOblivLong(order_raw[ii], 1);
			oram_read(&value, o, index);
			revealOblivInt(&temp, value, 0);
			success &= (temp == input_raw[ii]);
		}

		oram_free(o);

		fprintf(stderr, "Test Item: %-19s %-50s %s\n", getOramName(mode), "oram_write/oram_read", (success)?STATUS_SUCCESS:STATUS_FAILURE);

	}

	{
		uint32_t input_raw[256];
		uint32_t order_raw[256];
		obliv uint32_t input[256];

		for (int ii = 0; ii < 256; ii++) {
			input_raw[ii] = ii;
			order_raw[ii] = ii;
		}

		shuffle(order_raw, 256);

		for (int ii = 0; ii < 256; ii++) {
			input[ocBroadcastInt(order_raw[ii], 1)] = feedOblivInt(input_raw[ii], 2);
		}
		oram * o = oram_from_array(mode, &ocCopyInt, 256, input);

		bool success = true;

		for (int ii = 0; ii < 256; ii++) {
			uint32_t temp;
			obliv uint32_t value;
			obliv size_t index = feedOblivLong(order_raw[ii], 1);
			oram_read(&value, o, index);
			revealOblivInt(&temp, value, 0);
			success &= (temp == input_raw[ii]);
		}

		oram_free(o);

		fprintf(stderr, "Test Item: %-19s %-50s %s\n", getOramName(mode), "oram_from_array", (success)?STATUS_SUCCESS:STATUS_FAILURE);

	}

	{

		oram * o = oram_new(mode, &ocCopyInt, 256);

		bool success = true;

		for (int ii = -2; ii < 258; ii++) {
			bool temp;
			obliv bool write_success;
			obliv size_t index = feedOblivLong(ii, 1);
			obliv uint32_t value = feedOblivInt(rand(), 2);
			write_success = oram_write(o, &value, index);
			revealOblivBool(&temp, write_success, 0);
			success &= (temp == true && (ii >= 0 || ii < 256)) != (temp == false && (ii < 0 || ii >= 256));
		}

		oram_free(o);

		fprintf(stderr, "Test Item: %-19s %-50s %s\n", getOramName(mode), "oram_write - bounds checking", (success)?STATUS_SUCCESS:STATUS_FAILURE);

	}

	{
		uint32_t input_raw[256];
		uint32_t order_raw[256];

		for (int ii = 0; ii < 256; ii++) {
			input_raw[ii] = rand();
			order_raw[ii] = ii;
		}

		shuffle(input_raw, 256);
		shuffle(order_raw, 256);

		oram * o = oram_new(mode, &ocCopyInt, 256);

		for (int ii = 0; ii < 256; ii++) {
			obliv size_t index = feedOblivLong(order_raw[ii], 1);
			obliv uint32_t value = feedOblivInt(input_raw[ii], 2);
			oram_write(o, &value, index);
		}

		bool success = true;

		for (int ii = -2; ii < 258; ii++) {
			bool temp;
			obliv bool read_success;
			obliv uint32_t value;
			obliv size_t index = feedOblivLong(ii, 1);
			read_success = oram_read(&value, o, index);
			revealOblivBool(&temp, read_success, 0);
			success &= (temp == true && (ii >= 0 || ii < 256)) != (temp == false && (ii < 0 || ii >= 256));
		}

		oram_free(o);

		fprintf(stderr, "Test Item: %-19s %-50s %s\n", getOramName(mode), "oram_read - bounds checking", (success)?STATUS_SUCCESS:STATUS_FAILURE);

	}

	fprintf(stderr, "\n");

}

void testMain(void*varg) {
	testOramType(ORAM_TYPE_SQRT);
	testOramType(ORAM_TYPE_CIRCUIT);
	testOramType(ORAM_TYPE_LINEAR);
}